// @bun
var S$=Object.create;var{defineProperty:P1,getPrototypeOf:T$,getOwnPropertyNames:C$}=Object;var q$=Object.prototype.hasOwnProperty;var I0=($,Z,W)=>{W=$!=null?S$(T$($)):{};const J=Z||!$||!$.__esModule?P1(W,"default",{value:$,enumerable:!0}):W;for(let X of C$($))if(!q$.call(J,X))P1(J,X,{get:()=>$[X],enumerable:!0});return J};var K0=($,Z)=>()=>(Z||$((Z={exports:{}}).exports,Z),Z.exports);var C1=K0((F8,Z1)=>{var O0=function(){},L$=function($,Z,W){this.fn=$,this.context=Z,this.once=W||!1},T1=function($,Z,W,J,X){if(typeof W!=="function")throw new TypeError("The listener must be a function");var Q=new L$(W,J||$,X),Y=y?y+Z:Z;if(!$._events[Y])$._events[Y]=Q,$._eventsCount++;else if(!$._events[Y].fn)$._events[Y].push(Q);else $._events[Y]=[$._events[Y],Q];return $},v0=function($,Z){if(--$._eventsCount===0)$._events=new O0;else delete $._events[Z]},g=function(){this._events=new O0,this._eventsCount=0},R$=Object.prototype.hasOwnProperty,y="~";if(Object.create){if(O0.prototype=Object.create(null),!new O0().__proto__)y=!1}g.prototype.eventNames=function $(){var Z=[],W,J;if(this._eventsCount===0)return Z;for(J in W=this._events)if(R$.call(W,J))Z.push(y?J.slice(1):J);if(Object.getOwnPropertySymbols)return Z.concat(Object.getOwnPropertySymbols(W));return Z};g.prototype.listeners=function $(Z){var W=y?y+Z:Z,J=this._events[W];if(!J)return[];if(J.fn)return[J.fn];for(var X=0,Q=J.length,Y=new Array(Q);X<Q;X++)Y[X]=J[X].fn;return Y};g.prototype.listenerCount=function $(Z){var W=y?y+Z:Z,J=this._events[W];if(!J)return 0;if(J.fn)return 1;return J.length};g.prototype.emit=function $(Z,W,J,X,Q,Y){var B=y?y+Z:Z;if(!this._events[B])return!1;var G=this._events[B],z=arguments.length,K,_;if(G.fn){if(G.once)this.removeListener(Z,G.fn,void 0,!0);switch(z){case 1:return G.fn.call(G.context),!0;case 2:return G.fn.call(G.context,W),!0;case 3:return G.fn.call(G.context,W,J),!0;case 4:return G.fn.call(G.context,W,J,X),!0;case 5:return G.fn.call(G.context,W,J,X,Q),!0;case 6:return G.fn.call(G.context,W,J,X,Q,Y),!0}for(_=1,K=new Array(z-1);_<z;_++)K[_-1]=arguments[_];G.fn.apply(G.context,K)}else{var w=G.length,M;for(_=0;_<w;_++){if(G[_].once)this.removeListener(Z,G[_].fn,void 0,!0);switch(z){case 1:G[_].fn.call(G[_].context);break;case 2:G[_].fn.call(G[_].context,W);break;case 3:G[_].fn.call(G[_].context,W,J);break;case 4:G[_].fn.call(G[_].context,W,J,X);break;default:if(!K)for(M=1,K=new Array(z-1);M<z;M++)K[M-1]=arguments[M];G[_].fn.apply(G[_].context,K)}}}return!0};g.prototype.on=function $(Z,W,J){return T1(this,Z,W,J,!1)};g.prototype.once=function $(Z,W,J){return T1(this,Z,W,J,!0)};g.prototype.removeListener=function $(Z,W,J,X){var Q=y?y+Z:Z;if(!this._events[Q])return this;if(!W)return v0(this,Q),this;var Y=this._events[Q];if(Y.fn){if(Y.fn===W&&(!X||Y.once)&&(!J||Y.context===J))v0(this,Q)}else{for(var B=0,G=[],z=Y.length;B<z;B++)if(Y[B].fn!==W||X&&!Y[B].once||J&&Y[B].context!==J)G.push(Y[B]);if(G.length)this._events[Q]=G.length===1?G[0]:G;else v0(this,Q)}return this};g.prototype.removeAllListeners=function $(Z){var W;if(Z){if(W=y?y+Z:Z,this._events[W])v0(this,W)}else this._events=new O0,this._eventsCount=0;return this};g.prototype.off=g.prototype.removeListener;g.prototype.addListener=g.prototype.on;g.prefixed=y;g.EventEmitter=g;if(typeof Z1!=="undefined")Z1.exports=g});var m0=K0((j8,u1)=>{var l$=function($){var Z=$.indexOf("%");if(Z===-1)return $;var W=$.length,J="",X=0,Q=0,Y=Z,B=k1;while(Z>-1&&Z<W){var G=f1($[Z+1],4),z=f1($[Z+2],0),K=G|z,_=Q1[K];if(B=Q1[256+B+_],Q=Q<<6|K&Q1[364+_],B===k1)J+=$.slice(X,Y),J+=Q<=65535?String.fromCharCode(Q):String.fromCharCode(55232+(Q>>10),56320+(Q&1023)),Q=0,X=Z+3,Z=Y=$.indexOf("%",X);else if(B===p$)return null;else{if(Z+=3,Z<W&&$.charCodeAt(Z)===37)continue;return null}}return J+$.slice(X)},f1=function($,Z){var W=i$[$];return W===void 0?255:W<<Z},k1=12,p$=0,Q1=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,7,7,7,7,7,7,7,7,7,7,7,7,8,7,7,10,9,9,9,11,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,24,36,48,60,72,84,96,0,12,12,12,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,24,24,24,0,0,0,0,0,0,0,0,0,24,24,0,0,0,0,0,0,0,0,0,0,48,48,48,0,0,0,0,0,0,0,0,0,0,48,48,0,0,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,127,63,63,63,0,31,15,15,15,7,7,7],i$={"0":0,"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,a:10,A:10,b:11,B:11,c:12,C:12,d:13,D:13,e:14,E:14,f:15,F:15};u1.exports=l$});var W$=K0((m8,Z$)=>{var Z8=function($){const Z=new $$;if(typeof $!=="string")return Z;let W=$.length,J="",X="",Q=-1,Y=-1,B=!1,G=!1,z=!1,K=!1,_=!1,w=0;for(let M=0;M<W+1;M++)if(w=M!==W?$.charCodeAt(M):38,w===38){if(_=Y>Q,!_)Y=M;if(J=$.slice(Q+1,Y),_||J.length>0){if(z)J=J.replace(e1," ");if(B)J=a1(J)||J;if(_){if(X=$.slice(Y+1,M),K)X=X.replace(e1," ");if(G)X=a1(X)||X}const P=Z[J];if(P===void 0)Z[J]=X;else if(P.pop)P.push(X);else Z[J]=[P,X]}X="",Q=M,Y=M,B=!1,G=!1,z=!1,K=!1}else if(w===61)if(Y<=Q)Y=M;else G=!0;else if(w===43)if(Y>Q)K=!0;else z=!0;else if(w===37)if(Y>Q)G=!0;else B=!0;return Z},a1=m0(),e1=/\+/g,$$=function(){};$$.prototype=Object.create(null);Z$.exports=Z8});var J$=K0((d8,X$)=>{var X8=function($){const Z=$.length;if(Z===0)return"";let W="",J=0,X=0;$:for(;X<Z;X++){let Q=$.charCodeAt(X);while(Q<128){if(W8[Q]!==1){if(J<X)W+=$.slice(J,X);J=X+1,W+=r[Q]}if(++X===Z)break $;Q=$.charCodeAt(X)}if(J<X)W+=$.slice(J,X);if(Q<2048){J=X+1,W+=r[192|Q>>6]+r[128|Q&63];continue}if(Q<55296||Q>=57344){J=X+1,W+=r[224|Q>>12]+r[128|Q>>6&63]+r[128|Q&63];continue}if(++X,X>=Z)throw new Error("URI malformed");const Y=$.charCodeAt(X)&1023;J=X+1,Q=65536+((Q&1023)<<10|Y),W+=r[240|Q>>18]+r[128|Q>>12&63]+r[128|Q>>6&63]+r[128|Q&63]}if(J===0)return $;if(J<Z)return W+$.slice(J);return W},r=Array.from({length:256},($,Z)=>"%"+((Z<16?"0":"")+Z.toString(16)).toUpperCase()),W8=new Int8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0]);X$.exports={encodeString:X8}});var B$=K0((c8,Y$)=>{var Q$=function($){const Z=typeof $;if(Z==="string")return M1($);else if(Z==="bigint")return $.toString();else if(Z==="boolean")return $?"true":"false";else if(Z==="number"&&Number.isFinite($))return $<1000000000000000000000?""+$:M1(""+$);return""},J8=function($){let Z="";if($===null||typeof $!=="object")return Z;const W="&",J=Object.keys($),X=J.length;let Q=0;for(let Y=0;Y<X;Y++){const B=J[Y],G=$[B],z=M1(B)+"=";if(Y)Z+=W;if(Array.isArray(G)){Q=G.length;for(let K=0;K<Q;K++){if(K)Z+=W;Z+=z,Z+=Q$(G[K])}}else Z+=z,Z+=Q$(G)}return Z},{encodeString:M1}=J$();Y$.exports=J8});var A1=K0((p8,q0)=>{var G$=W$(),U$=B$(),K$={parse:G$,stringify:U$};q0.exports=K$;q0.exports.default=K$;q0.exports.parse=G$;q0.exports.stringify=U$});var z0=($,Z)=>({part:$,store:null,inert:Z!==void 0?new Map(Z.map((W)=>[W.part.charCodeAt(0),W])):null,params:null,wildcardStore:null}),V1=($,Z)=>({...$,part:Z}),S1=($)=>({paramName:$,store:null,inert:null});class W0{root={};history=[];static regex={static:/:.+?(?=\/|$)/,params:/:.+?(?=\/|$)/g};add($,Z,W){let J;if(typeof Z!="string")throw TypeError("Route path must be a string");Z===""?Z="/":Z[0]!=="/"&&(Z=`/${Z}`),this.history.push([$,Z,W]);let X=Z[Z.length-1]==="*";X&&(Z=Z.slice(0,-1));let Q=Z.split(W0.regex.static),Y=Z.match(W0.regex.params)||[];Q[Q.length-1]===""&&Q.pop(),J=this.root[$]?this.root[$]:this.root[$]=z0("/");let B=0;for(let G=0;G<Q.length;++G){let z=Q[G];if(G>0){let K=Y[B++].slice(1);if(J.params===null)J.params=S1(K);else if(J.params.paramName!==K)throw Error(`Cannot create route "${Z}" with parameter "${K}" because a route already exists with a different parameter name ("${J.params.paramName}") in the same location`);let _=J.params;if(_.inert===null){J=_.inert=z0(z);continue}J=_.inert}for(let K=0;;){if(K===z.length){if(K<J.part.length){let _=V1(J,J.part.slice(K));Object.assign(J,z0(z,[_]))}break}if(K===J.part.length){if(J.inert===null)J.inert=new Map;else if(J.inert.has(z.charCodeAt(K))){J=J.inert.get(z.charCodeAt(K)),z=z.slice(K),K=0;continue}let _=z0(z.slice(K));J.inert.set(z.charCodeAt(K),_),J=_;break}if(z[K]!==J.part[K]){let _=V1(J,J.part.slice(K)),w=z0(z.slice(K));Object.assign(J,z0(J.part.slice(0,K),[_,w])),J=w;break}++K}}if(B<Y.length){let G=Y[B],z=G.slice(1);if(J.params===null)J.params=S1(z);else if(J.params.paramName!==z)throw Error(`Cannot create route "${Z}" with parameter "${z}" because a route already exists with a different parameter name ("${J.params.paramName}") in the same location`);return J.params.store===null&&(J.params.store=W),J.params.store}return X?(J.wildcardStore===null&&(J.wildcardStore=W),J.wildcardStore):(J.store===null&&(J.store=W),J.store)}find($,Z){let W=this.root[$];return W?$1(Z,Z.length,W,0):null}}var $1=($,Z,W,J)=>{let X=W?.part,Q=J+X.length;if(X.length>1){if(Q>Z)return null;if(X.length<15){for(let Y=1,B=J+1;Y<X.length;++Y,++B)if(X.charCodeAt(Y)!==$.charCodeAt(B))return null}else if($.substring(J,Q)!==X)return null}if(Q===Z)return W.store!==null?{store:W.store,params:{}}:W.wildcardStore!==null?{store:W.wildcardStore,params:{"*":""}}:null;if(W.inert!==null){let Y=W.inert.get($.charCodeAt(Q));if(Y!==void 0){let B=$1($,Z,Y,Q);if(B!==null)return B}}if(W.params!==null){let Y=W.params,B=$.indexOf("/",Q);if(B!==Q){if(B===-1||B>=Z){if(Y.store!==null){let G={};return G[Y.paramName]=$.substring(Q,Z),{store:Y.store,params:G}}}else if(Y.inert!==null){let G=$1($,Z,Y.inert,B);if(G!==null)return G.params[Y.paramName]=$.substring(Q,B),G}}}return W.wildcardStore!==null?{store:W.wildcardStore,params:{"*":$.substring(Q,Z)}}:null};var q1=I0(C1(),1);var R1=q1.default;var k0=()=>{let $;return[new Promise((W)=>{$=W}),$]},$0=()=>{const[$,Z]=k0(),[W,J]=k0(),X=[],Q=[];return{signal:$,consume:(Y)=>{switch(Y.type){case"begin":if(Y.unit&&X.length===0)for(let B=0;B<Y.unit;B++){const[G,z]=k0(),[K,_]=k0();X.push(G),Q.push([(w)=>{z({children:[],end:K,name:w.name??"",skip:!1,time:w.time})},(w)=>{_(w)}])}Z({children:X,end:W,name:Y.name??"",skip:!1,time:Y.time});break;case"end":J(Y.time);break}},consumeChild(Y){switch(Y.type){case"begin":if(!Q[0])return;const[B]=Q[0];B({children:[],end:W,name:Y.name??"",skip:!1,time:Y.time});break;case"end":const G=Q.shift();if(!G)return;G[1](Y.time)}},resolve(){Z({children:[],end:new Promise((Y)=>Y(0)),name:"",skip:!0,time:0});for(let[Y,B]of Q)Y({children:[],end:new Promise((G)=>G(0)),name:"",skip:!0,time:0}),B(0);J(0)}}},L1=($,Z,W)=>{if(typeof W==="object")W=W.fn;return async function J(J){if(J.event!=="request"||J.type!=="begin")return;const X=J.id,Q=$(),Y=$0(),B=$0(),G=$0(),z=$0(),K=$0(),_=$0(),w=$0(),M=$0();Y.consume(J);const P=(N)=>{if(N.id===X)switch(N.event){case"request":Y.consume(N);break;case"request.unit":Y.consumeChild(N);break;case"parse":B.consume(N);break;case"parse.unit":B.consumeChild(N);break;case"transform":G.consume(N);break;case"transform.unit":G.consumeChild(N);break;case"beforeHandle":z.consume(N);break;case"beforeHandle.unit":z.consumeChild(N);break;case"handle":K.consume(N);break;case"afterHandle":_.consume(N);break;case"afterHandle.unit":_.consumeChild(N);break;case"error":w.consume(N);break;case"error.unit":w.consumeChild(N);break;case"response":if(N.type==="begin")Y.resolve(),B.resolve(),G.resolve(),z.resolve(),K.resolve(),_.resolve(),w.resolve();else Q.off("event",P);M.consume(N);break;case"response.unit":M.consumeChild(N);break;case"exit":Y.resolve(),B.resolve(),G.resolve(),z.resolve(),K.resolve(),_.resolve(),w.resolve();break}};Q.on("event",P),await W({id:X,context:J.ctx,set:J.ctx?.set,store:J.ctx?.store,time:J.time,request:Y.signal,parse:B.signal,transform:G.signal,beforeHandle:z.signal,handle:K.signal,afterHandle:_.signal,error:w.signal,response:M.signal}),Q.emit(`res${X}.${Z}`,void 0)}};var H1=($)=>{if($.startsWith("async"))$=$.slice(6);let Z=-1;if($.charCodeAt(0)===40){if(Z=$.indexOf(") => {\n"),Z!==-1)return[$.slice(1,Z),$.slice(Z+5)];if(Z=$.indexOf(") => "),Z!==-1)return[$.slice(1,Z),$.slice(Z+5)]}if($.startsWith("function")){Z=$.indexOf("(");const J=$.indexOf(")");return[$.slice(Z+1,J),$.slice(J+2)]}const W=$.indexOf("(");if(W!==-1){const[J,X]=$.split("\n",2),Q=J.lastIndexOf(")")+1;return[J.slice(W,Q),"{"+X]}return $.split("\n",2)},b1=($)=>{const Z=$.indexOf("{");if(Z===-1)return[-1,0];let W=Z+1,J=1;for(;W<$.length;W++){const X=$.charCodeAt(W);if(X===123)J++;else if(X===125)J--;if(J===0)break}if(J!==0)return[0,$.length];return[Z,W+1]},E$=($)=>{const Z=$.lastIndexOf("}");if(Z===-1)return[-1,0];let W=Z-1,J=1;for(;W>=0;W--){const X=$.charCodeAt(W);if(X===125)J++;else if(X===123)J--;if(J===0)break}if(J!==0)return[-1,0];return[W,Z+1]},f0=($)=>{if($.charCodeAt(0)===40)$=$.slice(1,-1);if($.charCodeAt(0)===123)$=$.slice(2,-2);while(!0){const[Z,W]=b1($);if(Z===-1)break;$=$.slice(0,Z-2)+$.slice(W+1)}return $.replace(/:/g,"").trim()},H$=($,Z)=>{const W=f0($);if(!Z.query&&W.includes("query"))Z.query=!0;if(!Z.headers&&W.includes("headers"))Z.headers=!0;if(!Z.body&&W.includes("body"))Z.body=!0;if(!Z.cookie&&W.includes("cookie"))Z.cookie=!0;if(!Z.set&&W.includes("set"))Z.set=!0;return W},b$=($,Z)=>{const W=f0($);if(!Z.request&&W.includes("request"))Z.request=!0;if(!Z.parse&&W.includes("parse"))Z.parse=!0;if(!Z.transform&&W.includes("transform"))Z.transform=!0;if(!Z.handle&&W.includes("handle"))Z.handle=!0;if(!Z.beforeHandle&&W.includes("beforeHandle"))Z.beforeHandle=!0;if(!Z.afterHandle&&W.includes("afterHandle"))Z.afterHandle=!0;if(!Z.error&&W.includes("error"))Z.error=!0;if(!Z.context&&W.includes("context"))Z.context=!0;if(!Z.store&&W.includes("store"))Z.store=!0;if(!Z.set&&W.includes("set"))Z.set=!0;return W},x1=($,Z,W)=>{const J=Z.indexOf($+"\n",W),X=Z.indexOf($+"\t",W),Q=Z.indexOf($+",",W),Y=Z.indexOf($+";",W),B=Z.indexOf($+" ",W);return[J,X,Q,Y,B].filter((G)=>G>0).sort((G,z)=>G-z)[0]||-1},x$=($,Z,W)=>{const J=Z.indexOf($+"]",W),X=Z.indexOf($+"'",W),Q=Z.indexOf($+'"',W);return[J,X,Q].filter((Y)=>Y>0).sort((Y,B)=>Y-B)[0]||-1},W1=($,Z,W=0)=>{if(W>5)return[];const J=[];let X=Z;while(!0){let Q=x1(" = "+$,X);if(Q===-1){const G=X.indexOf(" = "+$);if(G+3+$.length!==X.length)break;Q=G}const Y=X.slice(0,Q);let B=Y.slice(Y.lastIndexOf(" ")+1);if(B==="}"){const[G,z]=E$(Y);J.push(X.slice(G,z)),X=X.slice(Q+3+$.length);continue}while(B.charCodeAt(0)===44)B=B.slice(1);while(B.charCodeAt(0)===9)B=B.slice(1);J.push(B),X=X.slice(Q+3+$.length)}for(let Q of J){if(Q.charCodeAt(0)===123)continue;const Y=W1(Q,Z);if(Y.length>0)J.push(...Y)}return J},g1=($,Z)=>[$+"."+Z,$+'["'+Z+'"]',$+"['"+Z+"']"],y1=($)=>{if(!$)return;if(!$.includes(",")){if($.includes("..."))return $.slice($.indexOf("...")+3);return $}const W=$.indexOf("...");if(W===-1)return;return $.slice(W+3).trimEnd()},E1=($,Z,W)=>{const J=(X,Q)=>$.includes(Q+"."+X)||$.includes(Q+'["'+X+'"]')||$.includes(Q+"['"+X+"']");for(let X of Z){if(!X)continue;if(X.charCodeAt(0)===123){if(X=f0(X),!W.query&&X.includes("query"))W.query=!0;if(!W.headers&&X.includes("headers"))W.headers=!0;if(!W.body&&X.includes("body"))W.body=!0;if(!W.cookie&&X.includes("cookie"))W.cookie=!0;if(!W.set&&X.includes("set"))W.set=!0;continue}if($.includes("("+X+")")){W.query=!0,W.headers=!0,W.body=!0,W.cookie=!0,W.set=!0,W.queries=[],W.unknownQueries=!0;break}if(!W.query&&J("query",X))W.query=!0;if($.includes("return "+X)||g1("return "+X,"query").some((Q)=>$.includes(Q)))W.query=!0,W.unknownQueries=!0;if(W.query&&!W.unknownQueries)while(!0){let Q=X+".";if($.includes(Q+"query"))Q=X+".query";let Y=!1,B=$.indexOf(Q);if(B===-1)Y=!0,B=$.indexOf(X+'["');if(B===-1)Y=!0,B=$.indexOf(X+"['");if(B===-1&&$.indexOf(X+"[")!==-1){W.queries=[],W.unknownQueries=!0;break}if(B!==-1){let G=Y?x$("",$,B+Q.length+1):x1("",$,B+Q.length+1);if(G===-1)G=void 0;const z=B+X.length+1;$=$.slice(B+X.length+1);let K=$.slice(0,G?G-z:G).trimEnd();while(B!==-1)if(B=K.indexOf("."),B!==-1)K=K.slice(B+1);if(K.charCodeAt(K.length-1)===59)K=K.slice(0,-1);if(K.charCodeAt(K.length-1)===44)K=K.slice(0,-1);if(K.charCodeAt(K.length-1)===93)K=K.slice(0,-1);if(K.charCodeAt(K.length-1)===41)K=K.slice(0,-1);if(Y)K=K.replaceAll(/("|')/g,"");if(K&&!W.queries.includes(K)){W.queries.push(K);continue}}break}if(!W.headers&&J("headers",X))W.headers=!0;if(!W.body&&J("body",X))W.body=!0;if(!W.cookie&&J("cookie",X))W.cookie=!0;if(!W.set&&J("set",X))W.set=!0;if(W.query&&W.headers&&W.body&&W.cookie&&W.set)break}return Z},g$=($)=>{while(!0){const Z=$.indexOf("=");if(Z===-1)break;const W=$.indexOf(",",Z),J=$.indexOf("}",Z),X=[W,J].filter((Q)=>Q>0).sort((Q,Y)=>Q-Y)[0]||-1;if(X===-1){$=$.slice(0,Z);break}$=$.slice(0,Z)+$.slice(X)}return $.split(",").map((Z)=>Z.trim()).join(", ")},y$=($)=>{for(let Z of $){if(Z.charCodeAt(0)===123)return!1;if(Z.indexOf("'")!==-1)return!1;if(Z.indexOf('"')!==-1)return!1;if(Z.indexOf("\n")!==-1)return!1;if(Z.indexOf("\t")!==-1)return!1}return!0},v$=($,Z,W)=>{const J=(X,Q)=>$.includes(X+"."+Q)||$.includes(X+'["'+Q+'"]')||$.includes(X+"['"+Q+"']");for(let X of Z){if(X.charCodeAt(0)===123){if(X=f0(X),!W.request&&X.includes("request"))W.request=!0;if(!W.parse&&X.includes("parse"))W.parse=!0;if(!W.transform&&X.includes("transform"))W.transform=!0;if(!W.handle&&X.includes("handle"))W.handle=!0;if(!W.beforeHandle&&X.includes("beforeHandle"))W.beforeHandle=!0;if(!W.afterHandle&&X.includes("afterHandle"))W.afterHandle=!0;if(!W.error&&X.includes("error"))W.error=!0;if(!W.context&&X.includes("context"))W.context=!0;if(!W.store&&X.includes("store"))W.store=!0;if(!W.set&&X.includes("set"))W.set=!0;continue}if($.includes("("+X+")")){W.request=!0,W.parse=!0,W.transform=!0,W.handle=!0,W.beforeHandle=!0,W.afterHandle=!0,W.error=!0,W.context=!0,W.store=!0,W.set=!0;break}if(!W.request&&J("request",X))W.request=!0;if(!W.parse&&J("parse",X))W.parse=!0;if(!W.transform&&J("transform",X))W.transform=!0;if(!W.handle&&J("handle",X))W.handle=!0;if(!W.beforeHandle&&J("beforeHandle",X))W.beforeHandle=!0;if(!W.afterHandle&&J("afterHandle",X))W.afterHandle=!0;if(!W.error&&J("error",X))W.error=!0;if(!W.context&&J("context",X))W.context=!0;if(!W.store&&J("store",X))W.store=!0;if(!W.set&&J("set",X))W.set=!0;if(W.request&&W.parse&&W.transform&&W.handle&&W.beforeHandle&&W.afterHandle&&W.error&&W.context&&W.store&&W.set)break}return Z},u0=($,Z={queries:[],query:!1,headers:!1,body:!1,cookie:!1,set:!1,unknownQueries:!1})=>{const W=[];if($.handler&&typeof $.handler==="function")W.push($.handler);if($.beforeHandle?.length)W.push(...$.beforeHandle);if($.parse?.length)W.push(...$.parse);if($.error?.length)W.push(...$.error);if($.transform?.length)W.push(...$.transform);if($.afterHandle?.length)W.push(...$.afterHandle);if($.mapResponse?.length)W.push(...$.mapResponse);if($.request?.length)W.push(...$.request);if($.onResponse?.length)W.push(...$.onResponse);for(let J of W){if(!J)continue;const X="fn"in J?J.fn:J,[Q,Y]=H1(X.toString()),B=H$(Q,Z),G=y1(B);if(G){const K=W1(G,Y);K.splice(0,-1,G),E1(Y,K,Z)}const z=B||G;if(z&&["","return "].some((K)=>g1(K+z,"query").some((_)=>Y.includes(_))))Z.query=!0,Z.unknownQueries=!0;if(Z.query){E1(Y,["query"],Z);const K=Q.indexOf("query: {");if(K!==-1){const _=Q.slice(K+7),[w,M]=b1(_),P=g$(_.slice(w,M));for(let N of P.slice(1,-1).split(",")){const U=N.indexOf(":");if(U!==-1)N=N.slice(0,U);if(N=N.trim(),N&&!Z.queries.includes(N))Z.queries.push(N.trim())}}}if(Z.query&&Z.headers&&Z.body&&Z.cookie&&Z.set)break}if(!y$(Z.queries))Z.unknownQueries=!0,Z.queries=[];return Z},v1=($,Z={request:!1,parse:!1,transform:!1,handle:!1,beforeHandle:!1,afterHandle:!1,error:!1,context:!1,store:!1,set:!1})=>{for(let W of $){const[J,X]=H1(W.toString()),Q=b$(J,Z),Y=y1(Q);if(Y){const B=W1(Y,X);B.splice(0,-1,Y),v$(X,B,Z);continue}if(Z.request&&Z.parse&&Z.transform&&Z.handle&&Z.beforeHandle&&Z.afterHandle&&Z.error&&Z.context&&Z.store&&Z.set)break}return Z};import{Value as t0} from"@sinclair/typebox/value";import{Kind as B1} from"@sinclair/typebox";import{Value as c0} from"@sinclair/typebox/value";import{TypeCompiler as l1} from"@sinclair/typebox/compiler";var f$=function($,Z){if(typeof $!=="string")throw new TypeError("argument str must be a string");var W={},J=Z||{},X=J.decode||h$,Q=0;while(Q<$.length){var Y=$.indexOf("=",Q);if(Y===-1)break;var B=$.indexOf(";",Q);if(B===-1)B=$.length;else if(B<Y){Q=$.lastIndexOf(";",Y-1)+1;continue}var G=$.slice(Q,Y).trim();if(W[G]===void 0){var z=$.slice(Y+1,B).trim();if(z.charCodeAt(0)===34)z=z.slice(1,-1);W[G]=c$(z,X)}Q=B+1}return W},u$=function($,Z,W){var J=W||{},X=J.encode||m$;if(typeof X!=="function")throw new TypeError("option encode is invalid");if(!h0.test($))throw new TypeError("argument name is invalid");var Q=X(Z);if(Q&&!h0.test(Q))throw new TypeError("argument val is invalid");var Y=$+"="+Q;if(J.maxAge!=null){var B=J.maxAge-0;if(isNaN(B)||!isFinite(B))throw new TypeError("option maxAge is invalid");Y+="; Max-Age="+Math.floor(B)}if(J.domain){if(!h0.test(J.domain))throw new TypeError("option domain is invalid");Y+="; Domain="+J.domain}if(J.path){if(!h0.test(J.path))throw new TypeError("option path is invalid");Y+="; Path="+J.path}if(J.expires){var G=J.expires;if(!d$(G)||isNaN(G.valueOf()))throw new TypeError("option expires is invalid");Y+="; Expires="+G.toUTCString()}if(J.httpOnly)Y+="; HttpOnly";if(J.secure)Y+="; Secure";if(J.partitioned)Y+="; Partitioned";if(J.priority){var z=typeof J.priority==="string"?J.priority.toLowerCase():J.priority;switch(z){case"low":Y+="; Priority=Low";break;case"medium":Y+="; Priority=Medium";break;case"high":Y+="; Priority=High";break;default:throw new TypeError("option priority is invalid")}}if(J.sameSite){var K=typeof J.sameSite==="string"?J.sameSite.toLowerCase():J.sameSite;switch(K){case!0:Y+="; SameSite=Strict";break;case"lax":Y+="; SameSite=Lax";break;case"strict":Y+="; SameSite=Strict";break;case"none":Y+="; SameSite=None";break;default:throw new TypeError("option sameSite is invalid")}}return Y},h$=function($){return $.indexOf("%")!==-1?decodeURIComponent($):$},m$=function($){return encodeURIComponent($)},d$=function($){return k$.call($)==="[object Date]"||$ instanceof Date},c$=function($,Z){try{return Z($)}catch(W){return $}};/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */var X1=f$,J1=u$;var k$=Object.prototype.toString,h0=/^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;var m1=I0(m0(),1);class n{$;Z;W;constructor($,Z,W={}){this.name=$;this.jar=Z;this.initial=W}get cookie(){if(!(this.name in this.jar))return this.initial;return this.jar[this.name]}set cookie($){if(!(this.name in this.jar))this.jar[this.name]=this.initial;this.jar[this.name]=$}get value(){return this.cookie.value}set value($){if(!(this.name in this.jar))this.jar[this.name]=this.initial;this.jar[this.name].value=$}get expires(){return this.cookie.expires}set expires($){this.cookie.expires=$}get maxAge(){return this.cookie.maxAge}set maxAge($){this.cookie.maxAge=$}get domain(){return this.cookie.domain}set domain($){this.cookie.domain=$}get path(){return this.cookie.path}set path($){this.cookie.path=$}get secure(){return this.cookie.secure}set secure($){this.cookie.secure=$}get httpOnly(){return this.cookie.httpOnly}set httpOnly($){this.cookie.httpOnly=$}get sameSite(){return this.cookie.sameSite}set sameSite($){this.cookie.sameSite=$}get priority(){return this.cookie.priority}set priority($){this.cookie.priority=$}get secrets(){return this.cookie.secrets}set secrets($){this.cookie.secrets=$}update($){return this.cookie=Object.assign(this.cookie,typeof $==="function"?$(this.cookie):$),this}set($){return this.cookie=Object.assign({...this.initial,value:this.value},typeof $==="function"?$(this.cookie):$),this}remove(){if(this.value===void 0)return;return this.set({expires:new Date(0),maxAge:0,value:""}),this}toString(){return typeof this.value==="object"?JSON.stringify(this.value):this.value?.toString()??""}}var h1=($,Z,W)=>{if(!$.cookie)$.cookie={};return new Proxy(Z,{get(J,X){if(X in Z)return new n(X,$.cookie,Object.assign({},W??{},Z[X]));return new n(X,$.cookie,Object.assign({},W))}})},d0=async($,Z,{secret:W,sign:J,...X}={})=>{if(!Z)return h1($,{},X);const Q=typeof W==="string";if(J&&J!==!0&&!Array.isArray(J))J=[J];const Y={},B=X1(Z);for(let[G,z]of Object.entries(B)){let K=m1.default(z);if(J===!0||J?.includes(G)){if(!W)throw new Error("No secret is provided to cookie plugin");if(Q){const w=await Y1(K,W);if(w===!1)throw new P0(G);K=w}else{let w=!0;for(let M=0;M<W.length;M++){const P=await Y1(K,W[M]);if(P!==!1){w=!0,K=P;break}}if(!w)throw new P0(G)}}const _=K.charCodeAt(0);if(_===123||_===91)try{Y[G]={value:JSON.parse(K)};continue}catch{}if(_0(K)){Y[G]={value:parseInt(K)};continue}if(K==="true"){Y[G]={value:!0};continue}if(K==="false"){Y[G]={value:!1};continue}Y[G]={value:K}}return h1($,Y,X)};var V0="toJSON"in new Headers,l=($)=>{for(let Z in $)return!0;return!1},S0=($,Z)=>{const W=$.size;if(!Z&&W||W&&Z&&Z.status!==206&&Z.status!==304&&Z.status!==412&&Z.status!==416){if(Z){if(Z.headers instanceof Headers){if(V0)Z.headers=Z.headers.toJSON();else for(let[J,X]of Z.headers.entries())if(J in Z.headers)Z.headers[J]=X}return new Response($,{status:Z.status,headers:Object.assign({"accept-ranges":"bytes","content-range":`bytes 0-${W-1}/${W}`},Z.headers)})}return new Response($,{headers:{"accept-ranges":"bytes","content-range":`bytes 0-${W-1}/${W}`}})}return new Response($)},d1=($,Z)=>{if(!$)return $;$.delete("Set-Cookie");for(let W=0;W<Z.length;W++){const J=Z[W].indexOf("=");$.append("Set-Cookie",`${Z[W].slice(0,J)}=${Z[W].slice(J+1)||""}`)}return $},c1=($)=>{if(!$||!l($))return;const Z=[];for(let[W,J]of Object.entries($)){if(!W||!J)continue;const X=J.value;if(X===void 0||X===null)continue;Z.push(J1(W,typeof X==="object"?JSON.stringify(X):X+"",J))}if(Z.length===0)return;if(Z.length===1)return Z[0];return Z},h=($,Z,W)=>{if($?.$passthrough)$=$?.[$.$passthrough];if($?.[m])Z.status=$[m],$=$.response;if(l(Z.headers)||Z.status!==200||Z.redirect||Z.cookie){if(typeof Z.status==="string")Z.status=X0[Z.status];if(Z.redirect){if(Z.headers.Location=Z.redirect,!Z.status||Z.status<300||Z.status>=400)Z.status=302}if(Z.cookie&&l(Z.cookie))Z.headers["Set-Cookie"]=c1(Z.cookie);if(Z.headers["Set-Cookie"]&&Array.isArray(Z.headers["Set-Cookie"]))Z.headers=d1(new Headers(Z.headers),Z.headers["Set-Cookie"]);switch($?.constructor?.name){case"String":return new Response($,Z);case"Blob":return S0($,Z);case"Object":case"Array":return Response.json($,Z);case"ReadableStream":if(!Z.headers["content-type"]?.startsWith("text/event-stream"))Z.headers["content-type"]="text/event-stream; charset=utf-8";return W?.signal.addEventListener("abort",{handleEvent(){$.cancel(W)}},{once:!0}),new Response($,Z);case void 0:if(!$)return new Response("",Z);return Response.json($,Z);case"Response":const J={...Z.headers};if(V0)Z.headers=$.headers.toJSON();else for(let[X,Q]of $.headers.entries())if(X in Z.headers)Z.headers[X]=Q;for(let X in J)$.headers.append(X,J[X]);return $;case"Error":return s($,Z);case"Promise":return $.then((X)=>h(X,Z));case"Function":return h($(),Z);case"Number":case"Boolean":return new Response($.toString(),Z);case"Cookie":if($ instanceof n)return new Response($.value,Z);return new Response($?.toString(),Z);default:if($ instanceof Response){const X=Object.assign({},Z.headers);if(V0)Z.headers=$.headers.toJSON();else for(let[Q,Y]of $.headers.entries())if(Q in Z.headers)Z.headers[Q]=Y;for(let Q in X)$.headers.append(Q,X[Q]);return $}if($ instanceof Promise)return $.then((X)=>h(X,Z));if($ instanceof Error)return s($,Z);if("charCodeAt"in $){const X=$.charCodeAt(0);if(X===123||X===91){if(!Z.headers["Content-Type"])Z.headers["Content-Type"]="application/json";return new Response(JSON.stringify($),Z)}}return new Response($,Z)}}else switch($?.constructor?.name){case"String":return new Response($);case"Blob":return S0($,Z);case"Object":case"Array":return new Response(JSON.stringify($),{headers:{"content-type":"application/json"}});case"ReadableStream":return W?.signal.addEventListener("abort",{handleEvent(){$.cancel(W)}},{once:!0}),new Response($,{headers:{"Content-Type":"text/event-stream; charset=utf-8"}});case void 0:if(!$)return new Response("");return new Response(JSON.stringify($),{headers:{"content-type":"application/json"}});case"Response":return $;case"Error":return s($,Z);case"Promise":return $.then((J)=>{const X=o(J);if(X!==void 0)return X;return new Response("")});case"Function":return o($());case"Number":case"Boolean":return new Response($.toString());case"Cookie":if($ instanceof n)return new Response($.value,Z);return new Response($?.toString(),Z);default:if($ instanceof Response)return new Response($.body,{headers:{"Content-Type":"application/json"}});if($ instanceof Promise)return $.then((J)=>h(J,Z));if($ instanceof Error)return s($,Z);if("charCodeAt"in $){const J=$.charCodeAt(0);if(J===123||J===91){if(!Z.headers["Content-Type"])Z.headers["Content-Type"]="application/json";return new Response(JSON.stringify($),Z)}}return new Response($)}},u=($,Z,W)=>{if($===void 0||$===null)return;if($?.$passthrough)$=$?.[$.$passthrough];if($?.[m])Z.status=$[m],$=$.response;if(l(Z.headers)||Z.status!==200||Z.redirect||Z.cookie){if(typeof Z.status==="string")Z.status=X0[Z.status];if(Z.redirect){if(Z.headers.Location=Z.redirect,!Z.status||Z.status<300||Z.status>=400)Z.status=302}if(Z.cookie&&l(Z.cookie))Z.headers["Set-Cookie"]=c1(Z.cookie);if(Z.headers["Set-Cookie"]&&Array.isArray(Z.headers["Set-Cookie"]))Z.headers=d1(new Headers(Z.headers),Z.headers["Set-Cookie"]);switch($?.constructor?.name){case"String":return new Response($,Z);case"Blob":return S0($,Z);case"Object":case"Array":return Response.json($,Z);case"ReadableStream":if(!Z.headers["content-type"]?.startsWith("text/event-stream"))Z.headers["content-type"]="text/event-stream; charset=utf-8";return W?.signal.addEventListener("abort",{handleEvent(){$.cancel(W)}},{once:!0}),new Response($,Z);case void 0:if(!$)return;return Response.json($,Z);case"Response":const J=Object.assign({},Z.headers);if(V0)Z.headers=$.headers.toJSON();else for(let[X,Q]of $.headers.entries())if(!(X in Z.headers))Z.headers[X]=Q;for(let X in J)$.headers.append(X,J[X]);if($.status!==Z.status)Z.status=$.status;return $;case"Promise":return $.then((X)=>{const Q=u(X,Z);if(Q!==void 0)return Q});case"Error":return s($,Z);case"Function":return u($(),Z);case"Number":case"Boolean":return new Response($.toString(),Z);case"Cookie":if($ instanceof n)return new Response($.value,Z);return new Response($?.toString(),Z);default:if($ instanceof Response){const X={...Z.headers};if(V0)Z.headers=$.headers.toJSON();else for(let[Q,Y]of $.headers.entries())if(Q in Z.headers)Z.headers[Q]=Y;for(let Q in X)$.headers.append(Q,X[Q]);return $}if($ instanceof Promise)return $.then((X)=>u(X,Z));if($ instanceof Error)return s($,Z);if("charCodeAt"in $){const X=$.charCodeAt(0);if(X===123||X===91){if(!Z.headers["Content-Type"])Z.headers["Content-Type"]="application/json";return new Response(JSON.stringify($),Z)}}return new Response($,Z)}}else switch($?.constructor?.name){case"String":return new Response($);case"Blob":return S0($,Z);case"Object":case"Array":return new Response(JSON.stringify($),{headers:{"content-type":"application/json"}});case"ReadableStream":return W?.signal.addEventListener("abort",{handleEvent(){$.cancel(W)}},{once:!0}),new Response($,{headers:{"Content-Type":"text/event-stream; charset=utf-8"}});case void 0:if(!$)return new Response("");return new Response(JSON.stringify($),{headers:{"content-type":"application/json"}});case"Response":return $;case"Promise":return $.then((J)=>{const X=u(J,Z);if(X!==void 0)return X});case"Error":return s($,Z);case"Function":return o($());case"Number":case"Boolean":return new Response($.toString());case"Cookie":if($ instanceof n)return new Response($.value,Z);return new Response($?.toString(),Z);default:if($ instanceof Response)return new Response($.body,{headers:{"Content-Type":"application/json"}});if($ instanceof Promise)return $.then((J)=>u(J,Z));if($ instanceof Error)return s($,Z);if("charCodeAt"in $){const J=$.charCodeAt(0);if(J===123||J===91){if(!Z.headers["Content-Type"])Z.headers["Content-Type"]="application/json";return new Response(JSON.stringify($),Z)}}return new Response($)}},o=($,Z)=>{if($?.$passthrough)$=$?.[$.$passthrough];if($?.[m])return h($.response,{status:$[m],headers:{}});switch($?.constructor?.name){case"String":return new Response($);case"Blob":return S0($);case"Object":case"Array":return new Response(JSON.stringify($),{headers:{"content-type":"application/json"}});case"ReadableStream":return Z?.signal.addEventListener("abort",{handleEvent(){$.cancel(Z)}},{once:!0}),new Response($,{headers:{"Content-Type":"text/event-stream; charset=utf-8"}});case void 0:if(!$)return new Response("");return new Response(JSON.stringify($),{headers:{"content-type":"application/json"}});case"Response":return $;case"Error":return s($);case"Promise":return $.then(o);case"Function":return o($());case"Number":case"Boolean":return new Response($.toString());default:if($ instanceof Response)return new Response($.body,{headers:{"Content-Type":"application/json"}});if($ instanceof Promise)return $.then(o);if($ instanceof Error)return s($);const W=JSON.stringify($);if(W.charCodeAt(0)===123)return new Response(JSON.stringify($),{headers:{"Content-Type":"application/json"}});return new Response(W)}},s=($,Z)=>new Response(JSON.stringify({name:$?.name,message:$?.message,cause:$?.cause}),{status:Z?.status!==200?Z?.status??500:500,headers:Z?.headers});var $8=function($){let Z=$;while(Z.endsWith("="))Z=Z.slice(0,-1);return Z},U1=($,Z)=>{const W=new URL($);return W.pathname=Z,W.toString()},t$=($)=>typeof $==="function"&&/^\s*class\s+/.test($.toString())||$.toString().startsWith("[object ")||l(Object.getPrototypeOf($)),G1=($)=>$&&typeof $==="object"&&!Array.isArray($),i=($,Z,{skipKeys:W}={})=>{if(G1($)&&G1(Z))for(let[J,X]of Object.entries(Z)){if(W?.includes(J))continue;if(!G1(X)||!(J in $)||t$(X)){$[J]=X;continue}$[J]=i($[J],X)}return $},s$=($,Z)=>{const{properties:W,...J}=$??{},{properties:X,...Q}=Z??{};return i(J,Q)},b=($=[],Z=[])=>{if(!$)return[];if(!Z)return $;const W=[],J=[];if(!Array.isArray($))$=[$];if(!Array.isArray(Z))Z=[Z];for(let X of $)if(W.push(X),X.checksum)J.push(X.checksum);for(let X of Z)if(!J.includes(X.checksum))W.push(X);return W},r$=["start","request","parse","transform","resolve","beforeHandle","afterHandle","onResponse","mapResponse","trace","error","stop","body","headers","params","query","response","type","detail"],n$=r$.reduce(($,Z)=>($[Z]=!0,$),{}),o$=($,Z)=>{const W=(J)=>typeof J==="object"&&Object.keys(J).every(_0);if(W($)&&W(Z))return{...$,...Z};return Z??$},f=($,Z,{allowMacro:W=!1}={})=>{return{...W?{...$,...Z}:void 0,body:Z?.body??$?.body,headers:Z?.headers??$?.headers,params:Z?.params??$?.params,query:Z?.query??$?.query,response:o$($?.response,Z?.response),type:$?.type||Z?.type,detail:i(Z?.detail??{},$?.detail??{}),parse:b($?.parse,Z?.parse),transform:b($?.transform,Z?.transform),beforeHandle:b($?.beforeHandle,Z?.beforeHandle),afterHandle:b($?.afterHandle,Z?.afterHandle),onResponse:b($?.onResponse,Z?.onResponse),mapResponse:b($?.mapResponse,Z?.mapResponse),trace:b($?.trace,Z?.trace),error:b($?.error,Z?.error)}},k=($,{models:Z={},additionalProperties:W=!1,dynamic:J=!1})=>{if(!$)return;if(typeof $==="string"&&!($ in Z))return;const X=typeof $==="string"?Z[$]:$;if(X.type==="object"&&"additionalProperties"in X===!1)X.additionalProperties=W;if(J)return{schema:X,references:"",checkFunc:()=>{},code:"",Check:(Q)=>c0.Check(X,Q),Errors:(Q)=>c0.Errors(X,Q),Code:()=>""};return l1.Compile(X,Object.values(Z))},p0=($,{models:Z={},additionalProperties:W=!1,dynamic:J=!1})=>{if(!$)return;if(typeof $==="string"&&!($ in Z))return;const X=typeof $==="string"?Z[$]:$,Q=(B,G)=>{if(J)return{schema:B,references:"",checkFunc:()=>{},code:"",Check:(z)=>c0.Check(B,z),Errors:(z)=>c0.Errors(B,z),Code:()=>""};return l1.Compile(B,G)};if(B1 in X){if("additionalProperties"in X===!1)X.additionalProperties=W;return{200:Q(X,Object.values(Z))}}const Y={};return Object.keys(X).forEach((B)=>{const G=X[+B];if(typeof G==="string"){if(G in Z){const z=Z[G];z.type==="object"&&"additionalProperties"in z,Y[+B]=B1 in z?Q(z,Object.values(Z)):z}return}if(G.type==="object"&&"additionalProperties"in G===!1)G.additionalProperties=W;Y[+B]=B1 in G?Q(G,Object.values(Z)):G}),Y},a$=typeof Bun!=="undefined",e$=a$&&typeof Bun.hash==="function",T0=($)=>{if(e$)return Bun.hash($);let Z=9;for(let W=0;W<$.length;)Z=Math.imul(Z^$.charCodeAt(W++),387420489);return Z=Z^Z>>>9},i1=({validator:$,defaultConfig:Z={},config:W,dynamic:J,models:X})=>{let Q=k($,{dynamic:J,models:X,additionalProperties:!0});if(l(Z))if(Q)Q.schema=s$(Q.schema,W);else Q=k(T.Cookie({},Z),{dynamic:J,models:X,additionalProperties:!0});return Q},l0=($,Z,W)=>{const J=(X)=>{if(!X)return;if(!Array.isArray(X)){const Y=X;if(W&&!Y.checksum)Y.checksum=W;if(Y.scope==="scoped")Y.scope="local";return Y}const Q=[...X];for(let Y of Q){if(W&&!Y.checksum)Y.checksum=W;if(Y.scope==="scoped")Y.scope="local"}return Q};return{start:b($.start,J(Z?.start)),request:b($.request,J(Z?.request)),parse:b($.parse,J(Z?.parse)),transform:b($.transform,J(Z?.transform)),beforeHandle:b($.beforeHandle,J(Z?.beforeHandle)),afterHandle:b($.afterHandle,J(Z?.afterHandle)),mapResponse:b($.mapResponse,J(Z?.mapResponse)),onResponse:b($.onResponse,J(Z?.onResponse)),trace:$.trace,error:b($.error,J(Z?.error)),stop:b($.stop,J(Z?.stop))}},t1=($,Z,{skipIfHasType:W=!1}={})=>{if(!$)return $;if(!Array.isArray($)){if(W)$.scope??=Z;else $.scope=Z;return $}for(let J of $)if(W)J.scope??=Z;else J.scope=Z;return $},J0=($)=>{if(!$)return $;if(!Array.isArray($))switch($.scope){case"global":case"scoped":return{...$};default:return{fn:$}}const Z=[];for(let W of $)switch(W.scope){case"global":case"scoped":Z.push({...W});break}return Z},K1=($)=>{return{...$,type:$?.type,detail:$?.detail,parse:J0($?.parse),transform:J0($?.transform),beforeHandle:J0($?.beforeHandle),afterHandle:J0($?.afterHandle),onResponse:J0($?.onResponse),error:J0($?.error),mapResponse:J0($?.mapResponse)}},X0={Continue:100,"Switching Protocols":101,Processing:102,"Early Hints":103,OK:200,Created:201,Accepted:202,"Non-Authoritative Information":203,"No Content":204,"Reset Content":205,"Partial Content":206,"Multi-Status":207,"Already Reported":208,"Multiple Choices":300,"Moved Permanently":301,Found:302,"See Other":303,"Not Modified":304,"Temporary Redirect":307,"Permanent Redirect":308,"Bad Request":400,Unauthorized:401,"Payment Required":402,Forbidden:403,"Not Found":404,"Method Not Allowed":405,"Not Acceptable":406,"Proxy Authentication Required":407,"Request Timeout":408,Conflict:409,Gone:410,"Length Required":411,"Precondition Failed":412,"Payload Too Large":413,"URI Too Long":414,"Unsupported Media Type":415,"Range Not Satisfiable":416,"Expectation Failed":417,"I'm a teapot":418,"Misdirected Request":421,"Unprocessable Content":422,Locked:423,"Failed Dependency":424,"Too Early":425,"Upgrade Required":426,"Precondition Required":428,"Too Many Requests":429,"Request Header Fields Too Large":431,"Unavailable For Legal Reasons":451,"Internal Server Error":500,"Not Implemented":501,"Bad Gateway":502,"Service Unavailable":503,"Gateway Timeout":504,"HTTP Version Not Supported":505,"Variant Also Negotiates":506,"Insufficient Storage":507,"Loop Detected":508,"Not Extended":510,"Network Authentication Required":511},i0=Object.fromEntries(Object.entries(X0).map(([$,Z])=>[Z,$])),p1=new TextEncoder,F0=async($,Z)=>{if(typeof $!=="string")throw new TypeError("Cookie value must be provided as a string.");if(Z===null)throw new TypeError("Secret key must be provided.");const W=await crypto.subtle.importKey("raw",p1.encode(Z),{name:"HMAC",hash:"SHA-256"},!1,["sign"]),J=await crypto.subtle.sign("HMAC",W,p1.encode($));return $+"."+$8(Buffer.from(J).toString("base64"))},Y1=async($,Z)=>{if(typeof $!=="string")throw new TypeError("Signed cookie string must be provided.");if(Z===null)throw new TypeError("Secret key must be provided.");const W=$.slice(0,$.lastIndexOf("."));return await F0(W,Z)===$?W:!1},z1=($,Z,W=Z)=>{if(!$||typeof $!=="object"||!Z)return;for(let[J,X]of Object.entries(Z)){if(J in n$||!(J in $))continue;const Q=$[J];if(typeof Q==="function")Q(X);else if(typeof Q==="object")z1(Q,X,W)}},s1=({globalHook:$,localHook:Z})=>(W)=>(J,X)=>{if(typeof J==="function")J={fn:J};if("fn"in J||Array.isArray(J)){if(!Z[W])Z[W]=[];if(typeof Z[W]==="function")Z[W]=[Z[W]];if(Array.isArray(J))Z[W]=Z[W].concat(J);else Z[W].push(J);return}const{insert:Q="after",stack:Y="local"}=J;if(typeof X==="function")X={fn:X};if(Y==="global")if(!Array.isArray(X))if(Q==="before")$[W].unshift(X);else $[W].push(X);else if(Q==="before")$[W]=X.concat($[W]);else $[W]=$[W].concat(X);else{if(!Z[W])Z[W]=[];if(typeof Z[W]==="function")Z[W]=[Z[W]];if(!Array.isArray(X))if(Q==="before")Z[W].unshift(X);else Z[W].push(X);else if(Q==="before")Z[W]=X.concat(Z[W]);else Z[W]=Z[W].concat(X)}},_0=($)=>{if($.length<16)return $.trim().length!==0&&!Number.isNaN(Number($));if($.length===16){const Z=Number($);if(Z.toString()===$)return $.trim().length!==0&&!Number.isNaN(Z)}return!1};class _1{$;root=null;promises=[];constructor($=console.error){this.onError=$}get size(){return this.promises.length}add($){return this.promises.push($),this.root||=this.drain(),$}async drain(){while(this.promises.length>0)try{await this.promises[0],this.promises.shift()}catch($){this.onError($)}this.root=null}then($,Z){return(this.root??Promise.resolve()).then($,Z)}}var d=($)=>{if(!$)return $;if(!Array.isArray($)){if(typeof $==="function")return{fn:$};else if("fn"in $)return $}const Z=[];for(let W of $)if(typeof W==="function")Z.push({fn:W});else if("fn"in W)Z.push(W);return Z},r1=($)=>{return{...$,start:d($?.start),request:d($?.request),parse:d($?.parse),transform:d($?.transform),beforeHandle:d($?.beforeHandle),afterHandle:d($?.afterHandle),onResponse:d($?.onResponse),mapResponse:d($?.mapResponse),trace:d($?.trace),error:d($?.error),stop:d($?.stop)}},n1=($)=>{return{...$,start:$.start?.map((Z)=>Z.fn),request:$.request?.map((Z)=>Z.fn),parse:$.parse?.map((Z)=>Z.fn),transform:$.transform?.map((Z)=>Z.fn),beforeHandle:$.beforeHandle?.map((Z)=>Z.fn),afterHandle:$.afterHandle?.map((Z)=>Z.fn),onResponse:$.onResponse?.map((Z)=>Z.fn),mapResponse:$.mapResponse?.map((Z)=>Z.fn),trace:$.trace?.map((Z)=>Z.fn),error:$.error?.map((Z)=>Z.fn),stop:$.stop?.map((Z)=>Z.fn)}};var o1=typeof Bun!=="undefined"?Bun.env:typeof process!=="undefined"?process?.env:void 0,Q0=Symbol("ElysiaErrorCode"),m=Symbol("ElysiaResponse"),C0=(o1?.NODE_ENV??o1?.ENV)==="production",F1=($,Z)=>({[m]:X0[$]??$,response:Z??($ in i0?i0[$]:$),_type:void 0});class s0 extends Error{code="INTERNAL_SERVER_ERROR";status=500;constructor($){super($??"INTERNAL_SERVER_ERROR")}}class Y0 extends Error{code="NOT_FOUND";status=404;constructor($){super($??"NOT_FOUND")}}class r0 extends Error{Z;code="PARSE";status=400;constructor($,Z){super($??"PARSE");this.body=Z}}class P0 extends Error{$;code="INVALID_COOKIE_SIGNATURE";status=400;constructor($,Z){super(Z??`"${$}" has invalid cookie signature`);this.key=$}}class R extends Error{$;Z;W;code="VALIDATION";status=422;constructor($,Z,W){if(typeof W==="object"&&m in W)W=W.response;const J=C0?void 0:("Errors"in Z)?Z.Errors(W).First():t0.Errors(Z,W).First(),X=J?.schema.error?typeof J.schema.error==="function"?J.schema.error($,Z,W):J.schema.error:void 0,Q=J?.path||"root";let Y="";if(X)Y=typeof X==="object"?JSON.stringify(X):X+"";else if(C0)Y=JSON.stringify({type:"validation",on:$,message:J?.message,found:W});else{const B=Z?.schema??Z,G="Errors"in Z?[...Z.Errors(W)]:[...t0.Errors(Z,W)];let z;try{z=t0.Create(B)}catch(K){z={type:"Could not create expected value",message:K?.message,error:K}}Y=JSON.stringify({type:"validation",on:$,property:Q,message:J?.message,expected:z,found:W,errors:G},null,2)}super(Y);this.type=$;this.validator=Z;this.value=W;Object.setPrototypeOf(this,R.prototype)}get all(){return[...this.validator.Errors(this.value)]}static simplifyModel($){const Z="schema"in $?$.schema:$;try{return t0.Create(Z)}catch{return Z}}get model(){return R.simplifyModel(this.validator)}toResponse($){return new Response(this.message,{status:400,headers:{...$,"content-type":"application/json"}})}}var D1={open($){$.data.open?.($)},message($,Z){$.data.message?.($,Z)},drain($){$.data.drain?.($)},close($,Z,W){$.data.close?.($,Z,W)}};class D0{$;Z;validator;constructor($,Z){this.raw=$;this.data=Z;if(this.validator=$.data.validator,$.data.id)this.id=$.data.id;else{const W=new Uint32Array(1);crypto.getRandomValues(W),this.id=W[0].toString()}}get id(){return this.raw.data.id}set id($){this.raw.data.id=$}get publish(){return($,Z=void 0,W)=>{if(this.validator?.Check(Z)===!1)throw new R("message",this.validator,Z);if(typeof Z==="object")Z=JSON.stringify(Z);return this.raw.publish($,Z,W),this}}get send(){return($)=>{if(this.validator?.Check($)===!1)throw new R("message",this.validator,$);if(Buffer.isBuffer($))return this.raw.send($),this;if(typeof $==="object")$=JSON.stringify($);return this.raw.send($),this}}get subscribe(){return($)=>{return this.raw.subscribe($),this}}get unsubscribe(){return($)=>{return this.raw.unsubscribe($),this}}get cork(){return($)=>{return this.raw.cork($),this}}get close(){return()=>{return this.raw.close(),this}}get terminate(){return this.raw.terminate.bind(this.raw)}get isSubscribed(){return this.raw.isSubscribed.bind(this.raw)}get remoteAddress(){return this.raw.remoteAddress}}var z$=I0(A1(),1),_$=I0(m0(),1);import{Value as R0} from"@sinclair/typebox/value";var Q8=(new Headers()).toJSON,F$={value:0},D$=({hasTrace:$,hasTraceSet:Z=!1,addFn:W,condition:J={}})=>{if($)return W("\nconst reporter = getReporter()\n"),(X,{name:Q,attribute:Y="",unit:B=0}={})=>{const G=X.indexOf("."),z=G===-1;if(X!=="request"&&X!=="response"&&!J[z?X:X.slice(0,G)])return()=>{if(Z&&X==="afterHandle")W("\nawait traceDone\n")};if(z)Q||=X;else Q||="anonymous";W("\n"+`reporter.emit('event', {
					id,
					event: '${X}',
					type: 'begin',
					name: '${Q}',
					time: performance.now(),
					${z?`unit: ${B},`:""}
					${Y}
				})`.replace(/(\t| |\n)/g,"")+"\n");let K=!1;return()=>{if(K)return;if(K=!0,W("\n"+`reporter.emit('event', {
							id,
							event: '${X}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g,"")+"\n"),Z&&X==="afterHandle")W("\nawait traceDone\n")}};else return()=>()=>{}},L0=($)=>{const Z=$.indexOf(")");if($.charCodeAt(Z+2)===61&&$.charCodeAt(Z+5)!==123)return!0;return $.includes("return")},Y8=($,{injectResponse:Z=""}={})=>({composeValidation:(W,J=`c.${W}`)=>$?`c.set.status = 422; throw new ValidationError('${W}', ${W}, ${J})`:`c.set.status = 422; return new ValidationError('${W}', ${W}, ${J}).toResponse(c.set.headers)`,composeResponseValidation:(W="r")=>{const J=$?`throw new ValidationError('response', response[c.set.status], ${W})`:`return new ValidationError('response', response[c.set.status], ${W}).toResponse(c.set.headers)`;return`\n${Z}

			if(typeof ${W} === "object" && ELYSIA_RESPONSE in ${W}) {
				if(!(${W} instanceof Response) && response[${W}[ELYSIA_RESPONSE]]?.Check(${W}.response) === false) {
					if(!(response instanceof Error)) {
						c.set.status = ${W}[ELYSIA_RESPONSE]

						${J}
					}
				}
			} else if(!(${W} instanceof Response) && response[c.set.status]?.Check(${W}) === false) {
				if(!(response instanceof Error))
					${J}
			}\n`}}),M0=Symbol.for("TypeBox.Kind"),n0=($,Z)=>{if(!Z)return;if(M0 in Z&&Z[M0]===$)return!0;if(Z.type==="object"){const W=Z.properties;for(let J of Object.keys(W)){const X=W[J];if(X.type==="object"){if(n0($,X))return!0}else if(X.anyOf){for(let Q=0;Q<X.anyOf.length;Q++)if(n0($,X.anyOf[Q]))return!0}if(M0 in X&&X[M0]===$)return!0}return!1}return Z.properties&&M0 in Z.properties&&Z.properties[M0]===$},B0=($,Z)=>{if(!Z)return;if(Z.type==="object"){const W=Z.properties;if(!W)return!1;for(let J of Object.keys(W)){const X=W[J];if($ in X)return!0;if(X.type==="object"){if(B0($,X))return!0}else if(X.anyOf){for(let Q=0;Q<X.anyOf.length;Q++)if(B0($,X.anyOf[Q]))return!0}}return!1}return $ in Z},w1=Symbol.for("TypeBox.Transform"),A0=($)=>{if(!$)return;if($.type==="object"&&$.properties){const Z=$.properties;for(let W of Object.keys(Z)){const J=Z[W];if(J.type==="object"){if(A0(J))return!0}else if(J.anyOf){for(let Q=0;Q<J.anyOf.length;Q++)if(A0(J.anyOf[Q]))return!0}if(w1 in J)return!0}return!1}return w1 in $||$.properties&&w1 in $.properties},B8=($)=>{if(!$)return;const Z=$?.schema;if(Z&&"anyOf"in Z){let W=!1;const J=Z.anyOf[0].type;for(let X of Z.anyOf)if(X.type!==J){W=!0;break}if(!W)return J}return $.schema?.type},G8=/(?:return|=>) \S+\(/g,x=($)=>{const Z="fn"in $?$.fn:$;if(Z.constructor.name==="AsyncFunction")return!0;const W=Z.toString();if(W.includes("=> response.clone("))return!1;return!!W.match(G8)},o0=({app:$,path:Z,method:W,localHook:J,hooks:X,validator:Q,handler:Y,allowMeta:B=!1,appInference:{event:G,trace:z}})=>{const K=typeof Y==="function";if(!K)Y=h(Y,{headers:$.setHeaders??{}});const _=$.config.forceErrorEncapsulation&&(K||X.afterHandle.length>0||X.beforeHandle.length>0||X.transform.length>0)||X.error.length>0||$.event.error.length>0||typeof Bun==="undefined"||X.onResponse.length>0||X.onResponse.length>0||!!X.trace.length,w=K?"handler(c)":"handler",M=X.onResponse.length?`\n;(async () => {${X.onResponse.map((O,F)=>`await res${F}(c)`).join(";")}})();\n`:"",P=z,N=X.trace.length>0;let U="";const D=u0(Object.assign(J,{handler:Y}),G),j=D.query||!!Q.query,I=W!=="$INTERNALWS"&&W!=="GET"&&W!=="HEAD"&&X.type!=="none"&&(D.body||!!Q.body),L=$.setHeaders,q=L&&!!Object.keys(L).length,v=D.headers||Q.headers,e=D.cookie||!!Q.cookie,S=Q?.cookie?.schema;let V="";if(S?.sign){if(!S.secrets)throw new Error(`t.Cookie required secret which is not set in (${W}) ${Z}.`);const O=!S.secrets?void 0:typeof S.secrets==="string"?S.secrets:S.secrets[0];if(V+=`const _setCookie = c.set.cookie
		if(_setCookie) {`,S.sign===!0)V+=`for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${O}')
			}`;else for(let F of S.sign)V+=`if(_setCookie['${F}']?.value) { c.set.cookie['${F}'].value = await signCookie(_setCookie['${F}'].value, '${O}') }\n`;V+="}\n"}const{composeValidation:c,composeResponseValidation:b0}=Y8(_);if(v)U+=Q8?"c.headers = c.request.headers.toJSON()\n":`c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;if(e){const O=(A,C)=>{const H=S?.[A]??C;if(!H)return typeof C==="string"?`${A}: "${C}",`:`${A}: ${C},`;if(typeof H==="string")return`${A}: '${H}',`;if(H instanceof Date)return`${A}: new Date(${H.getTime()}),`;return`${A}: ${H},`},F=S?`{
			secret: ${S.secrets!==void 0?typeof S.secrets==="string"?`'${S.secrets}'`:"["+S.secrets.reduce((A,C)=>A+`'${C}',`,"")+"]":"undefined"},
			sign: ${S.sign===!0?!0:S.sign!==void 0?"["+S.sign.reduce((A,C)=>A+`'${C}',`,"")+"]":"undefined"},
			${O("domain")}
			${O("expires")}
			${O("httpOnly")}
			${O("maxAge")}
			${O("path","/")}
			${O("priority")}
			${O("sameSite")}
			${O("secure")}
		}`:"undefined";if(v)U+=`\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${F})\n`;else U+=`\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${F})\n`}if(j){let O=[];if(Q.query&&Q.query.schema.type==="object")O=Object.keys(Q.query.schema.properties);else for(let F of D.queries)if(O.indexOf(F)===-1)O.push(F);if($.config.forceDynamicQuery===!0||D.unknownQueries===!0||!O.length)U+=`if(c.qi !== -1) {
				c.query = parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1)).replace(/\\+/g, ' '))
			} else c.query = {}`;else U+=`if(c.qi !== -1) {
				let url = decodeURIComponent(
					c.request.url.slice(c.qi)
						.replace(/\\+/g, ' ')
					)

				${O.map((F,A)=>`
						${A===0?"let":""} memory = url.indexOf('&${F}=')
						if(memory === -1) memory = url.indexOf('?${F}=')
						let a${A}

						if(memory !== -1) {
							const start = memory + ${F.length+2}
							memory = url.indexOf('&', start)

							if(memory === -1) a${A} = url.slice(start)
							else a${A} = url.slice(start, memory)
						}`).join("\n")}

				c.query = {
					${O.map((F,A)=>`'${F}': a${A}`).join(", ")}
				}
			} else {
				c.query = {}
			}`}const x0=z.set,g0=D.cookie||D.set||x0||v||K&&q;if(N)U+="\nconst id = c.$$requestId\n";const E=D$({hasTrace:N,hasTraceSet:x0,condition:P,addFn:(O)=>{U+=O}});if(U+=_?"\n try {\n":"",x0){U+="\nconst traceDone = Promise.all([";for(let O=0;O<X.trace.length;O++)U+=`new Promise(r => { reporter.once(\`res\${id}.${O}\`, r) }),`;U+="])\n"}const G0=typeof Y==="function"&&x(Y),e0=e||I||x0||G0||!!X.mapResponse.length||X.parse.length>0||X.afterHandle.some(x)||X.beforeHandle.some(x)||X.transform.some(x),I$=E("parse",{unit:X.parse.length});if(I){const O=B8(Q?.body);if(X.type&&!Array.isArray(X.type)){if(X.type)switch(X.type){case"json":case"application/json":if(_)U+=`const tempBody = await c.request.text()
							
							try {
								c.body = JSON.parse(tempBody)
							} catch {
								throw new ParseError('Failed to parse body as found: ' + (typeof body === "string" ? "'" + body + "'" : body), body)
							}`;else U+="c.body = await c.request.json()";break;case"text":case"text/plain":U+="c.body = await c.request.text()\n";break;case"urlencoded":case"application/x-www-form-urlencoded":U+="c.body = parseQuery(await c.request.text())\n";break;case"arrayBuffer":case"application/octet-stream":U+="c.body = await c.request.arrayBuffer()\n";break;case"formdata":case"multipart/form-data":U+=`c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;break}if(X.parse.length)U+="}}"}else{const A=(()=>{if(X.parse.length&&O&&!Array.isArray(X.type)){const C=Q?.body?.schema;if(typeof C==="object"&&(n0("File",C)||n0("Files",C)))return`c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`}})();if(A)U+=A;else{if(U+="\n",U+=v?"let contentType = c.headers['content-type']":"let contentType = c.request.headers.get('content-type')",U+=`
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`,X.parse.length){U+="let used = false\n";const C=E("parse",{unit:X.parse.length});for(let H=0;H<X.parse.length;H++){const U0=E("parse.unit",{name:X.parse[H].fn.name}),Z0=`bo${H}`;if(H!==0)U+="if(!used) {\n";if(U+=`let ${Z0} = parse[${H}](c, contentType)\n`,U+=`if(${Z0} instanceof Promise) ${Z0} = await ${Z0}\n`,U+=`if(${Z0} !== undefined) { c.body = ${Z0}; used = true }\n`,U0(),H!==0)U+="}"}C()}if(X.parse.length)U+="if (!used)";U+=`
				switch (contentType) {
					case 'application/json':
						${_?`
						const tempBody = await c.request.text()
						
						try {
							c.body = JSON.parse(tempBody)
						} catch {
							throw new ParseError('Failed to parse body as found: ' + (typeof body === "string" ? "'" + body + "'" : body), body)
						}
						`:"c.body = await c.request.json()\n"}
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}\n`,U+="}\n"}}U+="\n"}if(I$(),X?.transform){const O=E("transform",{unit:X.transform.length});if(X.transform.length)U+="\nlet transformed\n";for(let F=0;F<X.transform.length;F++){const A=X.transform[F],C=E("transform.unit",{name:A.fn.name});U+=x(A)?`transformed = await transform[${F}](c)\n`:`transformed = transform[${F}](c)\n`,U+=`if(transformed?.[ELYSIA_RESPONSE])
				throw transformed
			else
				Object.assign(c, transformed)\n`,C()}O()}if(Q){if(U+="\n",Q.headers){if(B0("default",Q.headers.params))for(let[O,F]of Object.entries(R0.Default(Q.headers.schema,{}))){const A=typeof F==="object"?JSON.stringify(F):`'${F}'`;if(A)U+=`c.headers['${O}'] ??= ${A}\n`}if(U+=`if(headers.Check(c.headers) === false) {
				${c("headers")}
			}`,A0(Q.headers.schema))U+="\nc.headers = headers.Decode(c.headers)\n"}if(Q.params){if(B0("default",Q.params.schema))for(let[O,F]of Object.entries(R0.Default(Q.params.schema,{}))){const A=typeof F==="object"?JSON.stringify(F):`'${F}'`;if(A)U+=`c.params['${O}'] ??= ${A}\n`}if(U+=`if(params.Check(c.params) === false) {
				${c("params")}
			}`,A0(Q.params.schema))U+="\nc.params = params.Decode(c.params)\n"}if(Q.query){if(B0("default",Q.query.schema))for(let[O,F]of Object.entries(R0.Default(Q.query.schema,{}))){const A=typeof F==="object"?JSON.stringify(F):`'${F}'`;if(A)U+=`c.query['${O}'] ??= ${A}\n`}if(U+=`if(query.Check(c.query) === false) {
				${c("query")}
			}`,A0(Q.query.schema))U+="\nc.query = query.Decode(Object.assign({}, c.query))\n"}if(Q.body){if(B0("default",Q.body.schema))U+=`if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(R0.Default(Q.body.schema,null)??{})}, c.body)

    				if(body.Check(c.query) === false) {
        				${c("body")}
     			}
            }`;else U+=`if(body.Check(c.body) === false) {
			${c("body")}
		}`;if(A0(Q.body.schema))U+="\nc.body = body.Decode(c.body)\n"}if(l(Q.cookie?.schema.properties??{})){if(U+=`const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value\n`,B0("default",Q.cookie.schema))for(let[O,F]of Object.entries(R0.Default(Q.cookie.schema,{})))U+=`cookieValue['${O}'] = ${typeof F==="object"?JSON.stringify(F):F}\n`;U+=`if(cookie.Check(cookieValue) === false) {
				${c("cookie","cookieValue")}
			}`}}if(X?.beforeHandle){const O=E("beforeHandle",{unit:X.beforeHandle.length});let F=!1;for(let A=0;A<X.beforeHandle.length;A++){const C=X.beforeHandle[A],H=E("beforeHandle.unit",{name:C.fn.name}),U0=L0(C.fn.toString());if(C.subType==="resolve"){if(!F)F=!0,U+="\nlet resolved\n";U+=x(C)?`resolved = await beforeHandle[${A}](c);\n`:`resolved = beforeHandle[${A}](c);\n`,U+=`if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else
						Object.assign(c, resolved)\n`}else if(!U0)U+=x(C)?`await beforeHandle[${A}](c);\n`:`beforeHandle[${A}](c);\n`,H();else{U+="Object.assign(c, be);",U+=x(C)?`be = await beforeHandle[${A}](c);\n`:`be = beforeHandle[${A}](c);\n`,H(),U+="if(be !== undefined) {\n";const O$=E("afterHandle",{unit:X.transform.length});if(X.afterHandle){E("handle",{name:K?Y.name:void 0})();for(let p=0;p<X.afterHandle.length;p++){const y0=X.afterHandle[p],P$=L0(y0.fn.toString()),V$=E("afterHandle.unit",{name:y0.fn.name});if(U+="c.response = be\n",!P$)U+=x(y0.fn)?`await afterHandle[${p}](c, be)\n`:`afterHandle[${p}](c, be)\n`;else U+=x(y0.fn)?`af = await afterHandle[${p}](c)\n`:`af = afterHandle[${p}](c)\n`,U+="if(af !== undefined) { c.response = be = af }\n";V$()}}if(O(),O$(),Q.response)U+=b0("be");if(X.mapResponse.length){U+="c.response = be";for(let p=0;p<X.mapResponse.length;p++)U+=`\nif(mr === undefined) {
							mr = onMapResponse[${p}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}\n`}U+=V,U+="return mapEarlyResponse(be, c.set, c.request)}\n"}}O()}if(X?.afterHandle.length){const O=E("handle",{name:K?Y.name:void 0});if(X.afterHandle.length)U+=G0?`let r = c.response = await ${w};\n`:`let r = c.response = ${w};\n`;else U+=G0?`let r = await ${w};\n`:`let r = ${w};\n`;O();const F=E("afterHandle",{unit:X.afterHandle.length});for(let A=0;A<X.afterHandle.length;A++){const C=X.afterHandle[A],H=L0(C.fn.toString()),U0=E("afterHandle.unit",{name:C.fn.name});if(!H)U+=x(C.fn)?`await afterHandle[${A}](c)\n`:`afterHandle[${A}](c)\n`,U0();else if(U+=x(C.fn)?`af = await afterHandle[${A}](c)\n`:`af = afterHandle[${A}](c)\n`,U0(),Q.response)U+="if(af !== undefined) {",F(),U+=b0("af"),U+="c.response = af }";else U+="if(af !== undefined) {",F(),U+="c.response = af}\n"}if(F(),U+="r = c.response\n",Q.response)U+=b0();if(U+=V,X.mapResponse.length)for(let A=0;A<X.mapResponse.length;A++)U+=`\nmr = onMapResponse[${A}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr\n`;if(g0)U+="return mapResponse(r, c.set, c.request)\n";else U+="return mapCompactResponse(r, c.request)\n"}else{const O=E("handle",{name:K?Y.name:void 0});if(Q.response||X.mapResponse.length){if(U+=G0?`let r = await ${w};\n`:`let r = ${w};\n`,O(),Q.response)U+=b0();if(E("afterHandle")(),X.mapResponse.length){U+="c.response = r";for(let F=0;F<X.mapResponse.length;F++)U+=`\nif(mr === undefined) { 
						mr = onMapResponse[${F}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}\n`}if(U+=V,Y instanceof Response)U+=D.set?`if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${w}.clone(), c.set, c.request)
				else
					return ${w}.clone()`:`return ${w}.clone()`,U+="\n";else if(g0)U+="return mapResponse(r, c.set, c.request)\n";else U+="return mapCompactResponse(r, c.request)\n"}else if(P.handle||e){if(U+=G0?`let r = await ${w};\n`:`let r = ${w};\n`,O(),E("afterHandle")(),X.mapResponse.length){U+="c.response = r";for(let F=0;F<X.mapResponse.length;F++)U+=`\nif(mr === undefined) {
							mr = onMapResponse[${F}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}\n`}if(U+=V,g0)U+="return mapResponse(r, c.set, c.request)\n";else U+="return mapCompactResponse(r, c.request)\n"}else{O();const F=G0?`await ${w}`:w;if(E("afterHandle")(),Y instanceof Response)U+=D.set?`if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${w}.clone(), c.set, c.request)
				else
					return ${w}.clone()`:`return ${w}.clone()`,U+="\n";else if(g0)U+=`return mapResponse(${F}, c.set, c.request)\n`;else U+=`return mapCompactResponse(${F}, c.request)\n`}}if(_||M){if(U+="\n} catch(error) {",!e0)U+="return (async () => {";U+="const set = c.set\nif (!set.status || set.status < 300) set.status = error?.status || 500\n";const O=E("error",{unit:X.error.length});if(X.error.length){U+=`
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;for(let F=0;F<X.error.length;F++){const A=`er${F}`,C=E("error.unit",{name:X.error[F].fn.name});if(U+=`\nlet ${A} = handleErrors[${F}](c)\n`,x(X.error[F]))U+=`if (${A} instanceof Promise) ${A} = await ${A}\n`;C(),U+=`${A} = mapEarlyResponse(${A}, set, c.request)\n`,U+=`if (${A}) {`,U+=`return ${A} }\n`}}if(O(),U+="return handleError(c, error, true)\n\n",!e0)U+="})()";if(U+="}",M||N){U+=" finally { ";const F=E("response",{unit:X.onResponse.length});U+=M,F(),U+="}"}}return U=`const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery,
			isNotEmpty
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError,
			ParseError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent,
		ELYSIA_RESPONSE
	} = hooks

	${X.onResponse.length?`const ${X.onResponse.map((O,F)=>`res${F} = onResponse[${F}]`).join(",")}`:""}

	return ${e0?"async":""} function handle(c) {
		${X.beforeHandle.length?"let be":""}
		${X.afterHandle.length?"let af":""}
		${X.mapResponse.length?"let mr":""}

		${B?"c.schema = schema; c.defs = definitions":""}
		${U}
	}`,Function("hooks",U)({handler:Y,hooks:n1(X),validator:Q,handleError:$.handleError,utils:{mapResponse:h,mapCompactResponse:o,mapEarlyResponse:u,parseQuery:z$.parse,isNotEmpty:l},error:{NotFoundError:Y0,ValidationError:R,InternalServerError:s0,ParseError:r0},schema:$.router.history,definitions:$.definitions.type,ERROR_CODE:Q0,getReporter:()=>$.reporter,requestId:F$,parseCookie:d0,signCookie:F0,decodeURIComponent:_$.default,ELYSIA_RESPONSE:m})},j1=($)=>{const Z={event:{...$.inference.event,queries:[...$.inference.event.queries]},trace:{...$.inference.trace}};let W="",J="";const X=$.setHeaders;for(let U of Object.keys($.singleton.decorator))W+=`,${U}: app.singleton.decorator.${U}`;const Q=$.router,Y=$.event.trace.length>0;let B=`
	const route = router.find(request.method, path) ${Q.http.root.ALL?'?? router.find("ALL", path)':""}

	if (route === null)
		return ${$.event.error.length?"app.handleError(ctx, notFound)":$.event.request.length?`new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`:"error404.clone()"}

	ctx.params = route.params\n`;if(!($.config.precompile===!0||typeof $.config.precompile==="object"&&$.config.precompile.compose===!0))B+=`
			if(route.store.composed)
				return route.store.composed(ctx)

			if(route.store.compose)
				return (route.store.compose())(ctx)`;else B+="return route.store(ctx)";B+="\n";let z="";for(let[U,{code:D,all:j}]of Object.entries(Q.static.http.map))z+=`case '${U}':\nswitch(request.method) {\n${D}\n${j??"default: break map"}}\n\n`;const K=$.event.request.some(x),_=`\n
	const url = request.url
	const s = url.indexOf('/', 11)
	const qi = url.indexOf('?', s + 1)
	let path
	if(qi === -1)
		path = url.substring(s)
	else 
		path = url.substring(s, qi)\n`;if(J+=`const {
		app,
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError,
		error
	} = data

	const store = app.singleton.store
	const staticRouter = app.router.static.http
	const wsRouter = app.router.ws
	const router = app.router.http

	const notFound = new NotFoundError()

	${$.event.request.length?"const onRequest = app.event.request.map(x => x.fn)":""}
	${Q.static.http.variables}
	${$.event.error.length?"":`
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${K?"async":""} function map(request) {\n`,$.event.request.length)J+="let re";const w=D$({hasTrace:Y,hasTraceSet:Z.trace.set,condition:{request:Z.trace.request},addFn:(U)=>{J+=U}});if($.event.request.length){J+=`
			${Y?"const id = +requestId.value++":""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys(X??{}).length?"Object.assign({}, app.setHeaders)":"{}"},
					status: 200
				},
				error
				${Y?",$$requestId: +id":""}
				${W}
			}
		`;const U=w("request",{attribute:"ctx",unit:$.event.request.length});J+="\n try {\n";for(let D=0;D<$.event.request.length;D++){const j=$.event.request[D],I=L0(j.fn.toString()),L=x(j),q=w("request.unit",{name:$.event.request[D].fn.name});if(I)J+=`re = mapEarlyResponse(
					${L?"await":""} onRequest[${D}](ctx),
					ctx.set,
					request
				)\n`,q(),J+="if(re !== undefined) return re\n";else J+=`${L?"await":""} onRequest[${D}](ctx)\n`,q()}J+=`} catch (error) {
			return app.handleError(ctx, error)
		}`,U(),J+=_,J+="\nctx.qi = qi\n ctx.path = path\n"}else J+=_,J+=`${Y?"const id = +requestId.value++":""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys(X??{}).length?"Object.assign({}, app.setHeaders)":"{}"},
				status: 200
			},
			error
			${Y?",$$requestId: id":""}
			${W}
		}`,w("request",{unit:$.event.request.length,attribute:Z.trace.context||Z.trace.store||Z.trace.set?"ctx":""})();const M=$.router.static.ws,P=$.router.ws;if(Object.keys(M).length||P.history.length){J+=`
			if(request.method === 'GET') {
				switch(path) {`;for(let[U,D]of Object.entries(M))J+=`
					case '${U}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${D}(ctx)

						break`;J+=`
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}\n`}J+=`
		map: switch(path) {
			${z}

			default:
				break
		}

		${B}
	}`;const N=N1($);return $.handleError=N,Function("data",J)({app:$,mapEarlyResponse:u,NotFoundError:Y0,getReporter:()=>$.reporter,requestId:F$,handleError:N,error:F1})},N1=($)=>{let Z=`const {
		app: { event: { error: onErrorContainer, onResponse: resContainer } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	const onError = onErrorContainer.map(x => x.fn)
	const res = resContainer.map(x => x.fn)

	return ${$.event.error.find(x)?"async":""} function(context, error, skipGlobal) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(error[ELYSIA_RESPONSE]) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}\n`;for(let W=0;W<$.event.error.length;W++){const J=$.event.error[W],X=`${x(J)?"await ":""}onError[${W}](context)`;if(Z+="\nif(skipGlobal !== true) {\n",L0(J.fn.toString()))Z+=`r = ${X}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set, context.request)
			}\n`;else Z+=X+"\n";Z+="\n}\n"}return Z+=`if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 422
		return new Response(
			error.message,
			{ 
				headers: Object.assign(
					{ 'content-type': 'application/json'}, 
					set.headers
				), 
				status: set.status
			}
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set, context.request)
	}
}`,Function("inject",Z)({app:$,mapResponse:h,ERROR_CODE:Q0,ELYSIA_RESPONSE:m})},E0=($)=>`if(stc${$}) return stc${$}(ctx)
if(st${$}.compose) return (stc${$} = st${$}.compose())(ctx)

return st${$}(ctx)`;var a0=I0(A1(),1);var I1=($)=>async(Z)=>{const W=Z.url,J=W.indexOf("/",11),X=W.indexOf("?",J+1),Q=X===-1?W.substring(J):W.substring(J,X),Y={cookie:{},status:200,headers:{}},B=Object.assign({},$.singleton.decorator,{set:Y,store:$.singleton.store,request:Z,path:Q,qi:X});try{for(let D=0;D<$.event.request.length;D++){const j=$.event.request[D].fn;let I=j(B);if(I instanceof Promise)I=await I;if(I=u(I,Y),I)return I}const G=$.router.dynamic.find(Z.method,Q)??$.router.dynamic.find("ALL",Q);if(!G)throw new Y0;const{handle:z,hooks:K,validator:_,content:w}=G.store;let M;if(Z.method!=="GET"&&Z.method!=="HEAD")if(w)switch(w){case"application/json":M=await Z.json();break;case"text/plain":M=await Z.text();break;case"application/x-www-form-urlencoded":M=a0.parse(await Z.text());break;case"application/octet-stream":M=await Z.arrayBuffer();break;case"multipart/form-data":M={};const D=await Z.formData();for(let j of D.keys()){if(M[j])continue;const I=D.getAll(j);if(I.length===1)M[j]=I[0];else M[j]=I}break}else{let D=Z.headers.get("content-type");if(D){const j=D.indexOf(";");if(j!==-1)D=D.slice(0,j);for(let I=0;I<K.parse.length;I++){const L=K.parse[I].fn;let q=L(B,D);if(q instanceof Promise)q=await q;if(q){M=q;break}}if(M===void 0)switch(D){case"application/json":M=await Z.json();break;case"text/plain":M=await Z.text();break;case"application/x-www-form-urlencoded":M=a0.parse(await Z.text());break;case"application/octet-stream":M=await Z.arrayBuffer();break;case"multipart/form-data":M={};const I=await Z.formData();for(let L of I.keys()){if(M[L])continue;const q=I.getAll(L);if(q.length===1)M[L]=q[0];else M[L]=q}break}}}B.body=M,B.params=G?.params||void 0,B.query=X===-1?{}:a0.parse(W.substring(X+1)),B.headers={};for(let[D,j]of Z.headers.entries())B.headers[D]=j;const P=_?.cookie?.schema,N=Z.headers.get("cookie");if(N)B.cookie=await d0(B.set,N,P?{secret:P.secrets!==void 0?typeof P.secrets==="string"?P.secrets:P.secrets.join(","):void 0,sign:P.sign===!0?!0:P.sign!==void 0?typeof P.sign==="string"?P.sign:P.sign.join(","):void 0}:void 0);for(let D=0;D<K.transform.length;D++){const j=K.transform[D],I=j.fn(B);if(j.subType==="derive")if(I instanceof Promise)Object.assign(B,await I);else Object.assign(B,I);else if(I instanceof Promise)await I}if(_){if(_.headers){const D={};for(let j in Z.headers)D[j]=Z.headers.get(j);if(_.headers.Check(D)===!1)throw new R("header",_.headers,D)}if(_.params?.Check(B.params)===!1)throw new R("params",_.params,B.params);if(_.query?.Check(B.query)===!1)throw new R("query",_.query,B.query);if(_.cookie){const D={};for(let[j,I]of Object.entries(B.cookie))D[j]=I.value;if(_.cookie?.Check(D)===!1)throw new R("cookie",_.cookie,D)}if(_.body?.Check(M)===!1)throw new R("body",_.body,M)}for(let D=0;D<K.beforeHandle.length;D++){let j=K.beforeHandle[D].fn(B);if(j instanceof Promise)j=await j;if(j!==void 0){B.response=j;for(let L=0;L<K.afterHandle.length;L++){let q=K.afterHandle[L].fn(B);if(q instanceof Promise)q=await q;if(q)j=q}const I=u(j,B.set);if(I)return I}}let U=z(B);if(U instanceof Promise)U=await U;if(!K.afterHandle.length){const D=_?.response?.[U.status];if(D?.Check(U)===!1)throw new R("response",D,U)}else{B.response=U;for(let D=0;D<K.afterHandle.length;D++){let j=K.afterHandle[D].fn(B);if(j instanceof Promise)j=await j;const I=u(j,B.set);if(I!==void 0){const L=_?.response?.[U.status];if(L?.Check(I)===!1)throw new R("response",L,I);return I}}}if(B.set.cookie&&P?.sign){const D=!P.secrets?void 0:typeof P.secrets==="string"?P.secrets:P.secrets[0];if(P.sign===!0)for(let[j,I]of Object.entries(B.set.cookie))B.set.cookie[j].value=await F0(I.value,"${secret}");else for(let j of P.sign){if(!(j in P.properties))continue;if(B.set.cookie[j]?.value)B.set.cookie[j].value=await F0(B.set.cookie[j].value,D)}}return h(U,B.set)}catch(G){if(G.status)Y.status=G.status;return $.handleError(B,G)}finally{for(let G of $.event.onResponse)await G.fn(B)}},M$=($)=>async(Z,W)=>{const J=Object.assign(Z,{error:W,code:W.code});J.set=Z.set;for(let X=0;X<$.event.error.length;X++){let Y=$.event.error[X].fn(J);if(Y instanceof Promise)Y=await Y;if(Y!==void 0&&Y!==null)return h(Y,Z.set)}return new Response(typeof W.cause==="string"?W.cause:W.message,{headers:Z.set.headers,status:W.status??500})};import{TypeSystem as j0} from"@sinclair/typebox/system";import{Type as H0,FormatRegistry as N0} from"@sinclair/typebox";import{Value as w0} from"@sinclair/typebox/value";import{TypeSystemPolicy as w6,TypeSystem as j6,TypeSystemDuplicateFormat as N6,TypeSystemDuplicateTypeKind as I6} from"@sinclair/typebox/system";import{TypeCompiler as P6,TypeCheck as V6} from"@sinclair/typebox/compiler";var A$=/(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/,w$=/(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/,j$=/^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;try{j0.Format("email",($)=>/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]+(?:-[a-z0-9]+)*$/i.test($)),j0.Format("uuid",($)=>/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)),j0.Format("date",($)=>{const Z=$.replace(/"/g,"");if(A$.test(Z)||w$.test(Z)||j$.test(Z)){const W=new Date(Z);if(!Number.isNaN(W.getTime()))return!0}return!1}),j0.Format("date-time",($)=>{const Z=$.replace(/"/g,"");if(A$.test(Z)||w$.test(Z)||j$.test(Z)){const W=new Date(Z);if(!Number.isNaN(W.getTime()))return!0}return!1})}catch{}var T=Object.assign({},H0),N$=($)=>{if(typeof $==="string")switch($.slice(-1)){case"k":return+$.slice(0,$.length-1)*1024;case"m":return+$.slice(0,$.length-1)*1048576;default:return+$}return $},O1=($,Z)=>{if(!(Z instanceof Blob))return!1;if($.minSize&&Z.size<N$($.minSize))return!1;if($.maxSize&&Z.size>N$($.maxSize))return!1;if($.extension)if(typeof $.extension==="string"){if(!Z.type.startsWith($.extension))return!1}else{for(let W=0;W<$.extension.length;W++)if(Z.type.startsWith($.extension[W]))return!0;return!1}return!0},U8=j0.Type("Files",($,Z)=>{if(!Array.isArray(Z))return O1($,Z);if($.minItems&&Z.length<$.minItems)return!1;if($.maxItems&&Z.length>$.maxItems)return!1;for(let W=0;W<Z.length;W++)if(!O1($,Z[W]))return!1;return!0});if(!N0.Get("numeric"))N0.Set("numeric",($)=>!!$&&!isNaN(+$));if(!N0.Get("boolean"))N0.Set("boolean",($)=>$==="true"||$==="false");if(!N0.Get("ObjectString"))N0.Set("ObjectString",($)=>{let Z=$.charCodeAt(0);if(Z===9||Z===10||Z===32)Z=$.trimStart().charCodeAt(0);if(Z!==123&&Z!==91)return!1;try{return JSON.parse($),!0}catch{return!1}});var a={Numeric:($)=>{const Z=H0.Number($);return T.Transform(T.Union([T.String({format:"numeric",default:0}),T.Number($)],$)).Decode((W)=>{const J=+W;if(isNaN(J))return W;if($&&!w0.Check(Z,J))throw new R("property",Z,J);return J}).Encode((W)=>W)},Date:($)=>{const Z=H0.Date($);return T.Transform(T.Union([H0.Date($),T.String({format:"date",default:(new Date()).toISOString()}),T.String({format:"date-time",default:(new Date()).toISOString()})],$)).Decode((W)=>{if(W instanceof Date)return W;const J=new Date(W);if(!w0.Check(Z,J))throw new R("property",Z,J);return J}).Encode((W)=>{if(typeof W==="string")return new Date(W);return W})},BooleanString:($)=>{const Z=H0.Boolean($);return T.Transform(T.Union([T.String({format:"boolean",default:!1}),T.Boolean($)],$)).Decode((W)=>{if(typeof W==="string")return W==="true";if($&&!w0.Check(Z,W))throw new R("property",Z,W);return W}).Encode((W)=>W)},ObjectString:($={},Z)=>{const W=T.Object($,Z),J=JSON.stringify(w0.Create(W));return T.Transform(T.Union([T.String({format:"ObjectString",default:J}),W])).Decode((X)=>{if(typeof X==="string"){try{X=JSON.parse(X)}catch{throw new R("property",W,X)}if(!w0.Check(W,X))throw new R("property",W,X);return X}return X}).Encode((X)=>{if(typeof X==="string")try{X=JSON.parse(X)}catch{throw new R("property",W,X)}if(!w0.Check(W,X))throw new R("property",W,X);return JSON.stringify(X)})},File:j0.Type("File",O1),Files:($={})=>T.Transform(U8($)).Decode((Z)=>{if(Array.isArray(Z))return Z;return[Z]}).Encode((Z)=>Z),Nullable:($)=>T.Union([T.Null(),$]),MaybeEmpty:($)=>T.Union([T.Null(),T.Undefined(),$]),Cookie:($,Z)=>T.Object($,Z)};T.BooleanString=a.BooleanString;T.ObjectString=a.ObjectString;T.Numeric=a.Numeric;T.File=($={})=>a.File({default:"File",...$,extension:$?.type,type:"string",format:"binary"});T.Files=($={})=>a.Files({...$,elysiaMeta:"Files",default:"Files",extension:$?.type,type:"array",items:{...$,default:"Files",type:"string",format:"binary"}});T.Nullable=($)=>a.Nullable($);T.MaybeEmpty=a.MaybeEmpty;T.Cookie=a.Cookie;T.Date=a.Date;class t{config;server=null;dependencies={};reporter=new R1;_routes={};_types={Prefix:"",Scoped:!1,Singleton:{},Definitions:{},Metadata:{}};_ephemeral={};_volatile={};singleton={decorator:{},store:{},derive:{},resolve:{}};get store(){return this.singleton.store}get decorator(){return this.singleton.decorator}get _scoped(){return this.config.scoped}definitions={type:{},error:{}};extender={macros:[]};validator=null;event={start:[],request:[],parse:[],transform:[],beforeHandle:[],afterHandle:[],mapResponse:[],onResponse:[],trace:[],error:[],stop:[]};telemetry={stack:void 0};router={http:new W0,ws:new W0,dynamic:new W0,static:{http:{handlers:[],variables:"",map:{},all:""},ws:{}},history:[]};inference={event:{body:!1,cookie:!1,headers:!1,queries:[],query:!1,set:!1,unknownQueries:!1},trace:{request:!1,parse:!1,transform:!1,handle:!1,beforeHandle:!1,afterHandle:!1,error:!1,context:!1,store:!1,set:!1}};promisedModules=new _1;constructor($){if(this.config={forceErrorEncapsulation:!0,prefix:"",aot:!0,strictPath:!1,global:!1,cookie:{},analytic:!1,...$,experimental:$?.experimental??{transpiler:!1},seed:$?.seed===void 0?"":$?.seed},$?.analytic&&($?.name||$?.seed!==void 0))this.telemetry.stack=new Error().stack}getServer(){return this.server}get routes(){return this.router.history}routeTree=new Map;applyMacro($){if(this.extender.macros.length){const Z=s1({globalHook:this.event,localHook:$}),W={events:{global:this.event,local:$},onParse:Z("parse"),onTransform:Z("transform"),onBeforeHandle:Z("beforeHandle"),onAfterHandle:Z("afterHandle"),onResponse:Z("onResponse"),mapResponse:Z("mapResponse"),onError:Z("error")};for(let J of this.extender.macros)z1(J.fn(W),$)}}add($,Z,W,J,{allowMeta:X=!1,skipPrefix:Q=!1}={allowMeta:!1,skipPrefix:!1}){if(J=r1(J),Z!==""&&Z.charCodeAt(0)!==47)Z="/"+Z;if(this.config.prefix&&!Q&&!this.config.scoped)Z=this.config.prefix+Z;if(J?.type)switch(J.type){case"text":J.type="text/plain";break;case"json":J.type="application/json";break;case"formdata":J.type="multipart/form-data";break;case"urlencoded":J.type="application/x-www-form-urlencoded";break;case"arrayBuffer":J.type="application/octet-stream";break;default:break}const Y=this.definitions.type;let B,G,z,K,_,w;const M=!this.config.aot,P=Object.assign({},this.config.cookie),N={body:J?.body??this.validator?.body,headers:J?.headers??this.validator?.headers,params:J?.params??this.validator?.params,query:J?.query??this.validator?.query,cookie:J?.cookie??this.validator?.cookie,response:J?.response??this.validator?.response},U=()=>i1({validator:N.cookie,defaultConfig:this.config.cookie,config:P,dynamic:M,models:Y}),D=this.config.precompile===!0||typeof this.config.precompile==="object"&&this.config.precompile.schema===!0?{body:k(N.body,{dynamic:M,models:Y}),headers:k(N.headers,{dynamic:M,models:Y,additionalProperties:!0}),params:k(N.params,{dynamic:M,models:Y}),query:k(N.query,{dynamic:M,models:Y}),cookie:U(),response:p0(N.response,{dynamic:M,models:Y})}:{get body(){if(B)return B;return B=k(N.body,{dynamic:M,models:Y})},get headers(){if(G)return G;return k(N.headers,{dynamic:M,models:Y,additionalProperties:!0})},get params(){if(z)return z;return z=k(N.params,{dynamic:M,models:Y})},get query(){if(K)return K;return K=k(N.query,{dynamic:M,models:Y})},get cookie(){if(_)return _;return _=U()},get response(){if(w)return w;return w=p0(N.response,{dynamic:M,models:Y})}},j=Z.endsWith("/")?Z.slice(0,Z.length-1):Z+"/";J=f(J,{},{allowMacro:!0}),this.applyMacro(J);const I=f(this.event,J);if(this.config.aot===!1){if(this.router.dynamic.add($,Z,{validator:D,hooks:I,content:J?.type,handle:W}),this.config.strictPath===!1)this.router.dynamic.add($,j,{validator:D,hooks:I,content:J?.type,handle:W});this.router.history.push({method:$,path:Z,composed:null,handler:W,hooks:I});return}let L=void 0;const q=this.config.precompile===!0||typeof this.config.precompile==="object"&&this.config.precompile.compose===!0,v=q?o0({app:this,path:Z,method:$,localHook:f(J),hooks:I,validator:D,handler:W,allowMeta:X,appInference:{event:{...this.inference.event,queries:[...this.inference.event.queries]},trace:{...this.inference.trace}}}):(V)=>{if(L)return L(V);return(L=o0({app:this,path:Z,method:$,localHook:f(J),hooks:I,validator:D,handler:W,allowMeta:X,appInference:{event:{...this.inference.event,queries:[...this.inference.event.queries]},trace:{...this.inference.trace}}}))(V)};if(!q)v.compose=()=>{return v.composed=o0({app:this,path:Z,method:$,localHook:f(J),hooks:I,validator:D,handler:W,allowMeta:X,appInference:Object.assign({},this.inference)})};let e=this.router.history.length;if(this.routeTree.has($+Z)){if(e=this.router.history.findIndex((V)=>V.path===Z&&V.method===$),e!==-1){const V=this.router.history.splice(e,1)[0];if(V&&this.routeTree.has(V?.method+V?.path))this.routeTree.delete(V.method+V.path)}}this.routeTree.set($+Z,e),this.router.history.push({method:$,path:Z,composed:v,handler:W,hooks:I});const S=this.router.static.http;if($==="$INTERNALWS"){const V=this.config.strictPath?void 0:Z.endsWith("/")?Z.slice(0,Z.length-1):Z+"/";if(Z.indexOf(":")===-1&&Z.indexOf("*")===-1){const c=S.handlers.length;if(S.handlers.push(v),S.variables+=`const st${c} = staticRouter.handlers[${c}]\n`,this.router.static.ws[Z]=c,V)this.router.static.ws[V]=c}else if(this.router.ws.add("ws",Z,v),V)this.router.ws.add("ws",V,v);return}if(Z.indexOf(":")===-1&&Z.indexOf("*")===-1){const V=S.handlers.length;if(S.handlers.push(v),S.variables+=q?`const st${V} = staticRouter.handlers[${V}]\n`:`let st${V} = staticRouter.handlers[${V}]\nlet stc${V}\n`,!S.map[Z])S.map[Z]={code:""};if($==="ALL")S.map[Z].all=q?`default: return st${V}(ctx)\n`:`default: ${E0(V)}\n`;else S.map[Z].code=q?`case '${$}': return st${V}(ctx)\n${S.map[Z].code}`:`case '${$}': ${E0(V)}\n${S.map[Z].code}`;if(!this.config.strictPath){if(!S.map[j])S.map[j]={code:""};if($==="ALL")S.map[j].all=q?`default: return st${V}(ctx)\n`:`default: ${E0(V)}\n`;else S.map[j].code=q?`case '${$}': return st${V}(ctx)\n${S.map[j].code}`:`case '${$}': ${E0(V)}\n${S.map[j].code}`}}else if(this.router.http.add($,Z,v),!this.config.strictPath)this.router.http.add($,Z.endsWith("/")?Z.slice(0,Z.length-1):Z+"/",v)}setHeaders;headers($){if(!$)return this;if(!this.setHeaders)this.setHeaders={};return this.setHeaders=i(this.setHeaders,$),this}onStart($){return this.on("start",$),this}onRequest($){return this.on("request",$),this}onParse($,Z){if(!Z)return this.on("parse",$);return this.on($,"parse",Z)}onTransform($,Z){if(!Z)return this.on("transform",$);return this.on($,"transform",Z)}resolve($,Z){if(!Z)Z=$,$={as:"local"};const W={subType:"resolve",fn:Z};return this.onBeforeHandle($,W)}mapResolve($,Z){if(!Z)Z=$,$={as:"local"};const W={subType:"resolve",fn:Z};return this.onBeforeHandle($,W)}onBeforeHandle($,Z){if(!Z)return this.on("beforeHandle",$);return this.on($,"beforeHandle",Z)}onAfterHandle($,Z){if(!Z)return this.on("afterHandle",$);return this.on($,"afterHandle",Z)}mapResponse($,Z){if(!Z)return this.on("mapResponse",$);return this.on($,"mapResponse",Z)}onResponse($,Z){if(!Z)return this.on("response",$);return this.on($,"response",Z)}trace($,Z){if(!Z)Z=$,$={as:"local"};if(!Array.isArray(Z))Z=[Z];for(let W of Z)this.reporter.on("event",L1(()=>this.reporter,this.event.trace.length,W));return this.on($,"trace",Z),this}error($,Z){switch(typeof $){case"string":return Z.prototype[Q0]=$,this.definitions.error[$]=Z,this;case"function":return this.definitions.error=$(this.definitions.error),this}for(let[W,J]of Object.entries($))J.prototype[Q0]=W,this.definitions.error[W]=J;return this}onError($,Z){if(!Z)return this.on("error",$);return this.on($,"error",Z)}onStop($){return this.on("stop",$),this}on($,Z,W){let J;switch(typeof $){case"string":J=$,W=Z;break;case"object":J=Z;break}if(J==="response")J="onResponse";if(Array.isArray(W))W=d(W);else if(typeof W==="function")W=[{fn:W}];else W=[W];const X=W;for(let Q of X)Q.scope=typeof $==="string"?"local":$?.as??"local";if(J==="trace")v1(X.map((Q)=>Q.fn),this.inference.trace);else u0({[J]:X.map((Q)=>Q.fn)},this.inference.event);for(let Q of X){const Y=t1(Q,"global",{skipIfHasType:!0});switch(J){case"start":this.event.start.push(Y);break;case"request":this.event.request.push(Y);break;case"parse":this.event.parse.push(Y);break;case"transform":this.event.transform.push(Y);break;case"beforeHandle":this.event.beforeHandle.push(Y);break;case"afterHandle":this.event.afterHandle.push(Y);break;case"mapResponse":this.event.mapResponse.push(Y);break;case"onResponse":this.event.onResponse.push(Y);break;case"trace":this.event.trace.push(Y);break;case"error":this.event.error.push(Y);break;case"stop":this.event.stop.push(Y);break}}return this}propagate(){const $=(Z)=>{for(let W of Z)if("scope"in W&&W.scope==="local")W.scope="scoped"};return $(this.event.parse),$(this.event.transform),$(this.event.beforeHandle),$(this.event.afterHandle),$(this.event.mapResponse),$(this.event.onResponse),$(this.event.trace),$(this.event.error),this}group($,Z,W){const J=new t({...this.config||{},prefix:""});J.singleton={...this.singleton},J.definitions={...this.definitions},J.getServer=()=>this.server;const X=typeof Z==="object",Q=(X?W:Z)(J);if(this.singleton=i(this.singleton,J.singleton),this.definitions=i(this.definitions,J.definitions),Q.event.request.length)this.event.request=[...this.event.request||[],...Q.event.request||[]];if(Q.event.onResponse.length)this.event.onResponse=[...this.event.onResponse||[],...Q.event.onResponse||[]];return this.model(Q.definitions.type),Object.values(J.router.history).forEach(({method:Y,path:B,handler:G,hooks:z})=>{if(B=(X?"":this.config.prefix)+$+B,X){const K=Z,_=z;this.add(Y,B,G,f(K,{..._||{},error:!_.error?Q.event.error:Array.isArray(_.error)?[..._.error||{},...Q.event.error||{}]:[_.error,...Q.event.error||{}]}))}else this.add(Y,B,G,f(z,{error:Q.event.error}),{skipPrefix:!0})}),this}guard($,Z){if(!Z){if(typeof $==="object")return this.applyMacro($),this.event=l0(this.event,$),this.validator={body:$.body??this.validator?.body,headers:$.headers??this.validator?.headers,params:$.params??this.validator?.params,query:$.query??this.validator?.query,response:$.response??this.validator?.response,cookie:$.cookie??this.validator?.cookie},this;return this.guard({},$)}const W=new t({...this.config,prefix:""});W.singleton={...this.singleton},W.definitions={...this.definitions};const J=Z(W);if(this.singleton=i(this.singleton,W.singleton),this.definitions=i(this.definitions,W.definitions),J.getServer=()=>this.server,J.event.request.length)this.event.request=[...this.event.request||[],...J.event.request||[]];if(J.event.onResponse.length)this.event.onResponse=[...this.event.onResponse||[],...J.event.onResponse||[]];return this.model(J.definitions.type),Object.values(W.router.history).forEach(({method:X,path:Q,handler:Y,hooks:B})=>{this.add(X,Q,Y,f($,{...B||{},error:!B.error?J.event.error:Array.isArray(B.error)?[...B.error||{},...J.event.error||[]]:[B.error,...J.event.error||[]]},{allowMacro:!0}))}),this}use($,Z){if(Z?.scoped)return this.guard({},(W)=>W.use($));if(Array.isArray($)){let W=this;for(let J of $)W=this.use(J);return W}if($ instanceof Promise)return this.promisedModules.add($.then((W)=>{if(typeof W==="function")return W(this);if(W instanceof t)return this._use(W);if(typeof W.default==="function")return W.default(this);if(W.default instanceof t)return this._use(W.default);throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.')}).then((W)=>W.compile())),this;return this._use($)}_use($){if(typeof $==="function"){const X=$(this);if(X instanceof Promise)return this.promisedModules.add(X.then((Q)=>{if(Q instanceof t){this.compile();for(let{method:Y,path:B,handler:G,hooks:z}of Object.values(Q.router.history))this.add(Y,B,G,f(z,{error:Q.event.error}));return Q}if(typeof Q==="function")return Q(this);if(typeof Q.default==="function")return Q.default(this);return this._use(Q)}).then((Q)=>Q.compile())),this;return X}if($.promisedModules.size)return this.promisedModules.add($.modules.then(()=>this._use($)).then((X)=>X.compile())),this;const{name:Z,seed:W}=$.config;$.getServer=()=>this.getServer(),$.model(this.definitions.type),$.error(this.definitions.error);const J=$.config.scoped;if(J){if(Z){if(!(Z in this.dependencies))this.dependencies[Z]=[];const Q=W!==void 0?T0(Z+JSON.stringify(W)):0;if(this.dependencies[Z].some(({checksum:Y})=>Q===Y))return this;this.dependencies[Z].push(!this.config?.analytic?{name:$.config.name,seed:$.config.seed,checksum:Q,dependencies:$.dependencies}:{name:$.config.name,seed:$.config.seed,checksum:Q,dependencies:$.dependencies,stack:$.telemetry.stack,routes:$.router.history,decorators:$.singleton.decorator,store:$.singleton.store,type:$.definitions.type,error:$.definitions.error,derive:$.event.transform.filter((Y)=>Y.subType==="derive").map((Y)=>({fn:Y.fn.toString(),stack:new Error().stack??""})),resolve:$.event.transform.filter((Y)=>Y.subType==="derive").map((Y)=>({fn:Y.fn.toString(),stack:new Error().stack??""}))})}$.extender.macros=this.extender.macros.concat($.extender.macros);const X=[];for(let Q=0;Q<$.extender.macros.length;Q++){const Y=this.extender.macros[Q];if(X.includes(Y.checksum))$.extender.macros.splice(Q,1),Q--;X.push(Y.checksum)}if($.onRequest((Q)=>{Object.assign(Q,this.singleton.decorator),Object.assign(Q.store,this.singleton.store)}),$.event.trace.length)$.event.trace.push(...$.event.trace);if(!$.config.prefix)console.warn("It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.");if($.event.error.length)$.event.error.push(...this.event.error);if($.config.aot)$.compile();if(J===!0&&$.config.prefix){this.mount($.config.prefix+"/",$.fetch);for(let Q of $.router.history)this.routeTree.set(Q.method+`${$.config.prefix}${Q.path}`,this.router.history.length),this.router.history.push({...Q,path:`${$.config.prefix}${Q.path}`,hooks:f(Q.hooks,{error:this.event.error})})}else{this.mount($.fetch);for(let Q of $.router.history)this.routeTree.set(Q.method+`${$.config.prefix}${Q.path}`,this.router.history.length),this.router.history.push({...Q,path:`${$.config.prefix}${Q.path}`,hooks:f(Q.hooks,{error:this.event.error})})}return this}else{this.headers($.setHeaders),$.reporter=this.reporter;for(let Q of $.event.trace)if(Q.scope&&Q.scope!=="local")this.trace(Q);if(Z){if(!(Z in this.dependencies))this.dependencies[Z]=[];const Q=W!==void 0?T0(Z+JSON.stringify(W)):0;if(!this.dependencies[Z].some(({checksum:Y})=>Q===Y))this.extender.macros=this.extender.macros.concat($.extender.macros)}else this.extender.macros=this.extender.macros.concat($.extender.macros);const X=[];for(let Q=0;Q<this.extender.macros.length;Q++){const Y=this.extender.macros[Q];if(Y.checksum){if(X.includes(Y.checksum))this.extender.macros.splice(Q,1),Q--;X.push(Y.checksum)}}this.inference={event:{body:this.inference.event.body||$.inference.event.body,cookie:this.inference.event.cookie||$.inference.event.cookie,headers:this.inference.event.headers||$.inference.event.headers,queries:[...this.inference.event.queries,...$.inference.event.queries],query:this.inference.event.query||$.inference.event.query,set:this.inference.event.set||$.inference.event.set,unknownQueries:this.inference.event.unknownQueries||$.inference.event.unknownQueries},trace:{request:this.inference.trace.request||$.inference.trace.request,parse:this.inference.trace.parse||$.inference.trace.parse,transform:this.inference.trace.transform||$.inference.trace.transform,handle:this.inference.trace.handle||$.inference.trace.handle,beforeHandle:this.inference.trace.beforeHandle||$.inference.trace.beforeHandle,afterHandle:this.inference.trace.afterHandle||$.inference.trace.afterHandle,error:this.inference.trace.error||$.inference.trace.error,context:this.inference.trace.context||$.inference.trace.context,store:this.inference.trace.store||$.inference.trace.store,set:this.inference.trace.set||$.inference.trace.set}}}this.decorate($.singleton.decorator),this.state($.singleton.store),this.model($.definitions.type),this.error($.definitions.error);for(let{method:X,path:Q,handler:Y,hooks:B}of Object.values($.router.history))this.add(X,Q,Y,f(B,{error:$.event.error}));if(!J)if(Z){if(!(Z in this.dependencies))this.dependencies[Z]=[];const X=W!==void 0?T0(Z+JSON.stringify(W)):0;if(this.dependencies[Z].some(({checksum:Q})=>X===Q))return this;this.dependencies[Z].push(!this.config?.analytic?{name:$.config.name,seed:$.config.seed,checksum:X,dependencies:$.dependencies}:{name:$.config.name,seed:$.config.seed,checksum:X,dependencies:$.dependencies,stack:$.telemetry.stack,routes:$.router.history,decorators:$.singleton,store:$.singleton.store,type:$.definitions.type,error:$.definitions.error,derive:$.event.transform.filter((Q)=>Q?.subType==="derive").map((Q)=>({fn:Q.toString(),stack:new Error().stack??""})),resolve:$.event.transform.filter((Q)=>Q?.subType==="resolve").map((Q)=>({fn:Q.toString(),stack:new Error().stack??""}))}),this.event=l0(this.event,K1($.event),X)}else this.event=l0(this.event,K1($.event));return this}macro($){const Z={checksum:T0(JSON.stringify({name:this.config.name,seed:this.config.seed,content:$.toString()})),fn:$};return this.extender.macros.push(Z),this}mount($,Z){if($ instanceof t||typeof $==="function"||$.length===0||$==="/"){const X=typeof $==="function"?$:$ instanceof t?$.compile().fetch:Z instanceof t?Z.compile().fetch:Z,Q=async({request:Y,path:B})=>X(new Request(U1(Y.url,B||"/"),Y));return this.all("/*",Q,{type:"none"}),this}const W=$.length;if(Z instanceof t)Z=Z.compile().fetch;const J=async({request:X,path:Q})=>Z(new Request(U1(X.url,Q.slice(W)||"/"),X));return this.all($,J,{type:"none"}),this.all($+($.endsWith("/")?"*":"/*"),J,{type:"none"}),this}get($,Z,W){return this.add("GET",$,Z,W),this}post($,Z,W){return this.add("POST",$,Z,W),this}put($,Z,W){return this.add("PUT",$,Z,W),this}patch($,Z,W){return this.add("PATCH",$,Z,W),this}delete($,Z,W){return this.add("DELETE",$,Z,W),this}options($,Z,W){return this.add("OPTIONS",$,Z,W),this}all($,Z,W){return this.add("ALL",$,Z,W),this}head($,Z,W){return this.add("HEAD",$,Z,W),this}connect($,Z,W){return this.add("CONNECT",$,Z,W),this}route($,Z,W,J){return this.add($.toUpperCase(),Z,W,J,J?.config),this}ws($,Z){const W=Z.transformMessage?Array.isArray(Z.transformMessage)?Z.transformMessage:[Z.transformMessage]:void 0;let J=null;const X=k(Z?.body,{models:this.definitions.type}),Q=k(Z?.response,{models:this.definitions.type}),Y=(B)=>{if(typeof B==="string"){const G=B?.charCodeAt(0);if(G===47||G===123)try{B=JSON.parse(B)}catch{}else if(_0(B))B=+B}if(W?.length)for(let G=0;G<W.length;G++){const z=W[G](B);if(z!==void 0)B=z}return B};return this.route("$INTERNALWS",$,(B)=>{const{set:G,path:z,qi:K,headers:_,query:w,params:M}=B;if(J===null)J=this.getServer();if(J?.upgrade(B.request,{headers:typeof Z.upgrade==="function"?Z.upgrade(B):Z.upgrade,data:{validator:Q,open(P){Z.open?.(new D0(P,B))},message:(P,N)=>{const U=Y(N);if(X?.Check(U)===!1)return void P.send(new R("message",X,U).message);Z.message?.(new D0(P,B),U)},drain(P){Z.drain?.(new D0(P,B))},close(P,N,U){Z.close?.(new D0(P,B),N,U)}}}))return;return G.status=400,"Expected a websocket connection"},{beforeHandle:Z.beforeHandle,transform:Z.transform,headers:Z.headers,params:Z.params,query:Z.query}),this}state($,Z){switch(typeof $){case"object":return this.singleton.store=i(this.singleton.store,$),this;case"function":return this.singleton.store=$(this.singleton.store),this}if(!($ in this.singleton.store))this.singleton.store[$]=Z;return this}decorate($,Z){switch(typeof $){case"object":return this.singleton.decorator=i(this.singleton.decorator,$),this;case"function":return this.singleton.decorator=$(this.singleton.decorator),this}if(!($ in this.singleton.decorator))this.singleton.decorator[$]=Z;return this}derive($,Z){if(!Z)Z=$,$={as:"local"};const W={subType:"derive",fn:Z};return this.onTransform($,W)}model($,Z){switch(typeof $){case"object":return Object.entries($).forEach(([W,J])=>{if(!(W in this.definitions.type))this.definitions.type[W]=J}),this;case"function":return this.definitions.type=$(this.definitions.type),this}return this.definitions.type[$]=Z,this}mapDerive($,Z){if(!Z)Z=$,$={as:"local"};const W={subType:"derive",fn:Z};return this.onTransform($,W)}affix($,Z,W){if(W==="")return this;const J=["_","-"," "],X=(G)=>G[0].toUpperCase()+G.slice(1),Q=$==="prefix"?(G,z)=>J.includes(G.at(-1)??"")?G+z:G+X(z):J.includes(W.at(-1)??"")?(G,z)=>z+G:(G,z)=>z+X(G),Y=(G)=>{const z={};switch(G){case"decorator":for(let K in this.singleton.decorator)z[Q(W,K)]=this.singleton.decorator[K];this.singleton.decorator=z;break;case"state":for(let K in this.singleton.store)z[Q(W,K)]=this.singleton.store[K];this.singleton.store=z;break;case"model":for(let K in this.definitions.type)z[Q(W,K)]=this.definitions.type[K];this.definitions.type=z;break;case"error":for(let K in this.definitions.error)z[Q(W,K)]=this.definitions.error[K];this.definitions.error=z;break}},B=Array.isArray(Z)?Z:[Z];for(let G of B.some((z)=>z==="all")?["decorator","state","model","error"]:B)Y(G);return this}prefix($,Z){return this.affix("prefix",$,Z)}suffix($,Z){return this.affix("suffix",$,Z)}compile(){if(this.fetch=this.config.aot?j1(this):I1(this),typeof this.server?.reload==="function")this.server.reload({...this.server||{},fetch:this.fetch});return this}handle=async($)=>this.fetch($);fetch=($)=>{return(this.fetch=this.config.aot?j1(this):I1(this))($)};handleError=async($,Z)=>(this.handleError=this.config.aot?N1(this):M$(this))($,Z);outerErrorHandler=($)=>new Response($.message||$.name||"Error",{status:$?.status??500});listen=($,Z)=>{if(typeof Bun==="undefined")throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");if(this.compile(),typeof $==="string"){if(!_0($))throw new Error("Port must be a numeric value");$=parseInt($)}const W=this.fetch,J=typeof $==="object"?{development:!C0,reusePort:!0,...this.config.serve||{},...$||{},websocket:{...this.config.websocket||{},...D1||{}},fetch:W,error:this.outerErrorHandler}:{development:!C0,reusePort:!0,...this.config.serve||{},websocket:{...this.config.websocket||{},...D1||{}},port:$,fetch:W,error:this.outerErrorHandler};this.server=Bun?.serve(J);for(let X=0;X<this.event.start.length;X++)this.event.start[X].fn(this);if(Z)Z(this.server);return process.on("beforeExit",()=>{if(this.server){this.server.stop(),this.server=null;for(let X=0;X<this.event.stop.length;X++)this.event.stop[X].fn(this)}}),this.promisedModules.then(()=>{Bun?.gc(!1)}),this};stop=async()=>{if(!this.server)throw new Error("Elysia isn't running. Call `app.listen` to start the server.");if(this.server){if(this.server.stop(),this.server=null,this.event.stop.length)for(let $=0;$<this.event.stop.length;$++)this.event.stop[$].fn(this)}};get modules(){return Promise.all(this.promisedModules.promises)}}export{T as t,b as mergeObjectArray,f as mergeHook,h as mapResponse,u as mapEarlyResponse,o as mapCompactResponse,k as getSchemaValidator,p0 as getResponseSchemaValidator,F1 as error,t as default,R as ValidationError,X0 as StatusMap,r0 as ParseError,Y0 as NotFoundError,i0 as InvertedStatusMap,P0 as InvalidCookieSignature,s0 as InternalServerError,t as Elysia,Q0 as ERROR_CODE,m as ELYSIA_RESPONSE,n as Cookie};

//# debugId=B43294ABFD74078864756e2164756e21
