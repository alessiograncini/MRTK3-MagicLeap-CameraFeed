{"version":3,"sources":["../src/zpp.ts"],"sourcesContent":["/* eslint-disable no-redeclare */\nimport endent from \"endent\";\nimport type { z, ZodRawShape } from \"zod\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport type { JsonSchema7Type } from \"zod-to-json-schema/src/parseDef.js\";\n\ninterface ZodExtraMethods<In, Out, T extends z.ZodType<Out, z.ZodTypeDef, In>> {\n  new: (obj: z.infer<T>) => z.infer<T>;\n  jsonParse: (data: unknown) => z.infer<T>;\n  jsonParseAsync: (data: unknown) => Promise<z.infer<T>>;\n  jsonParseSafe: (data: unknown) => z.SafeParseReturnType<In, Out>;\n  toPrompt: () => string;\n  stringify: (data: z.infer<T>) => string;\n  toOpenAiFuncSchema: () => JsonSchema7Type & {\n    $schema?: string | undefined;\n    definitions?: Record<string, JsonSchema7Type> | undefined;\n  };\n}\n\nexport type ExtendedZodType<T extends z.ZodType<any, any>> = T &\n  ZodExtraMethods<InType<T>, OutType<T>, T>;\n\ntype InType<T> = T extends z.ZodType<any, any, infer In> ? In : never;\ntype OutType<T> = T extends z.ZodType<infer Out, any, any> ? Out : never;\n\nexport function zpp<T extends z.ZodObject<any, any, any, any, any>>(\n  schema: T,\n): ExtendedZodType<T>;\n\nexport function zpp<T extends z.ZodDiscriminatedUnion<any, any>>(\n  schema: T,\n): ExtendedZodType<T>;\n\nexport function zpp<T extends z.ZodType<any, any>>(\n  schema: T,\n): ExtendedZodType<T>;\n\nexport function zpp(schema: any) {\n  const newFunc = (obj: z.infer<typeof schema>) => {\n    return obj;\n  };\n\n  const parseJson = (data: unknown) => {\n    if (typeof data === \"string\") {\n      return schema.parse(JSON.parse(data));\n    }\n    if (typeof data === \"object\") {\n      return schema.parse(data);\n    }\n\n    throw new Error(\"Invalid data type\");\n  };\n\n  const parseJsonAsync = async (data: unknown) => {\n    if (typeof data === \"string\") {\n      return schema.parseAsync(JSON.parse(data));\n    }\n    if (typeof data === \"object\") {\n      return schema.parseAsync(data);\n    }\n\n    throw new Error(\"Invalid data type\");\n  };\n\n  const stringify = (data: z.infer<typeof schema>) => {\n    return JSON.stringify(data);\n  };\n\n  const parseJsonSafe = (data: unknown) => {\n    if (typeof data === \"string\") {\n      try {\n        return schema.safeParse(JSON.parse(data));\n      } catch (err) {\n        return schema.safeParse(data);\n      }\n    }\n    if (typeof data === \"object\") {\n      return schema.safeParse(data);\n    }\n\n    throw new Error(\"Invalid data type\");\n  };\n\n  const outputPrompt = (objectSchema: z.ZodObject<ZodRawShape>) => {\n    let output = \"{\";\n\n    const keys = Object.keys(objectSchema.shape);\n\n    for (const key of keys) {\n      const shape = objectSchema.shape[key];\n      if (!shape) throw new Error(\"Invalid Shape\");\n\n      const def = shape._def;\n\n      if (def.typeName === \"ZodObject\") {\n        // @ts-expect-error\n        output = `${output}\\n\"${key}\": ${outputPrompt(shape)}`;\n        continue;\n      }\n\n      let typeName = def.typeName;\n\n      if (typeName === \"ZodOptional\") {\n        typeName = def.innerType._def.typeName;\n      }\n\n      const describe: string | undefined = def.description;\n\n      switch (typeName) {\n        case \"ZodString\":\n          output = `${output}\\n\"${key}\": ${\n            describe ? `\"${describe}\"` : \"string\"\n          },`;\n          break;\n        case \"ZodNumber\":\n          output = `${output}\\n\"${key}\": number${\n            describe ? ` // ${describe}` : \"\"\n          },`;\n          break;\n        case \"ZodBoolean\":\n          output = `${output}\\n\"${key}\": boolean${\n            describe ? ` // ${describe}` : \"\"\n          },`;\n          break;\n      }\n    }\n\n    // Replace trailing comma\n    output = output.replace(/,\\s*$/, \"\");\n\n    output = endent`${output}\\n}`;\n\n    return output;\n  };\n\n  const toOpenAiFuncSchema = () => {\n    return zodToJsonSchema(schema);\n  };\n\n  const newSchema = Object.assign(schema, {\n    new: newFunc,\n    jsonParse: parseJson,\n    jsonParseSafe: parseJsonSafe,\n    jsonParseAsync: parseJsonAsync,\n    toPrompt: () => {\n      if (schema._def.typeName !== \"ZodObject\")\n        throw new Error(\"Cannot use toPrompt on non-object schema\");\n      return outputPrompt(schema);\n    },\n    stringify,\n    toOpenAiFuncSchema,\n  });\n\n  return newSchema;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,oBAAmB;AAEnB,gCAAgC;AAkCzB,SAAS,IAAI,QAAa;AAC/B,QAAM,UAAU,CAAC,QAAgC;AAC/C,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,CAAC,SAAkB;AACnC,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,OAAO,MAAM,KAAK,MAAM,IAAI,CAAC;AAAA,IACtC;AACA,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,OAAO,MAAM,IAAI;AAAA,IAC1B;AAEA,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAEA,QAAM,iBAAiB,OAAO,SAAkB;AAC9C,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,OAAO,WAAW,KAAK,MAAM,IAAI,CAAC;AAAA,IAC3C;AACA,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,OAAO,WAAW,IAAI;AAAA,IAC/B;AAEA,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAEA,QAAM,YAAY,CAAC,SAAiC;AAClD,WAAO,KAAK,UAAU,IAAI;AAAA,EAC5B;AAEA,QAAM,gBAAgB,CAAC,SAAkB;AACvC,QAAI,OAAO,SAAS,UAAU;AAC5B,UAAI;AACF,eAAO,OAAO,UAAU,KAAK,MAAM,IAAI,CAAC;AAAA,MAC1C,SAAS,KAAP;AACA,eAAO,OAAO,UAAU,IAAI;AAAA,MAC9B;AAAA,IACF;AACA,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,OAAO,UAAU,IAAI;AAAA,IAC9B;AAEA,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAEA,QAAM,eAAe,CAAC,iBAA2C;AAC/D,QAAI,SAAS;AAEb,UAAM,OAAO,OAAO,KAAK,aAAa,KAAK;AAE3C,eAAW,OAAO,MAAM;AACtB,YAAM,QAAQ,aAAa,MAAM,GAAG;AACpC,UAAI,CAAC;AAAO,cAAM,IAAI,MAAM,eAAe;AAE3C,YAAM,MAAM,MAAM;AAElB,UAAI,IAAI,aAAa,aAAa;AAEhC,iBAAS,GAAG,MAAM;AAAA,GAAM,GAAG,MAAM,aAAa,KAAK,CAAC;AACpD;AAAA,MACF;AAEA,UAAI,WAAW,IAAI;AAEnB,UAAI,aAAa,eAAe;AAC9B,mBAAW,IAAI,UAAU,KAAK;AAAA,MAChC;AAEA,YAAM,WAA+B,IAAI;AAEzC,cAAQ,UAAU;AAAA,QAChB,KAAK;AACH,mBAAS,GAAG,MAAM;AAAA,GAAM,GAAG,MACzB,WAAW,IAAI,QAAQ,MAAM,QAC/B;AACA;AAAA,QACF,KAAK;AACH,mBAAS,GAAG,MAAM;AAAA,GAAM,GAAG,YACzB,WAAW,OAAO,QAAQ,KAAK,EACjC;AACA;AAAA,QACF,KAAK;AACH,mBAAS,GAAG,MAAM;AAAA,GAAM,GAAG,aACzB,WAAW,OAAO,QAAQ,KAAK,EACjC;AACA;AAAA,MACJ;AAAA,IACF;AAGA,aAAS,OAAO,QAAQ,SAAS,EAAE;AAEnC,aAAS,cAAAA,UAAS,MAAM;AAExB,WAAO;AAAA,EACT;AAEA,QAAM,qBAAqB,MAAM;AAC/B,eAAO,2CAAgB,MAAM;AAAA,EAC/B;AAEA,QAAM,YAAY,OAAO,OAAO,QAAQ;AAAA,IACtC,KAAK;AAAA,IACL,WAAW;AAAA,IACX,eAAe;AAAA,IACf,gBAAgB;AAAA,IAChB,UAAU,MAAM;AACd,UAAI,OAAO,KAAK,aAAa;AAC3B,cAAM,IAAI,MAAM,0CAA0C;AAC5D,aAAO,aAAa,MAAM;AAAA,IAC5B;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,SAAO;AACT;","names":["endent"]}